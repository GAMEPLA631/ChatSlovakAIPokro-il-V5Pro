<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatSlovak AI Pokro캜il칳 V5 Pro (s Obr치zkami)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f003e; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            position: relative; 
            overflow: hidden;
        }
        #bg-canvas {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; 
            display: block;
        }
        #chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            
            /* SKLENEN칗 EFEKT */
            background-color: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(15px); 
            -webkit-backdrop-filter: blur(15px); 
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); 
            overflow: hidden;
            z-index: 10; 
        }
        
        .chat-header {
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-footer {
            background-color: rgba(255, 255, 255, 0.05); 
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .user-message {
            background-color: #3b82f6; 
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }
        .ai-message {
            background-color: rgba(255, 255, 255, 0.85); 
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.25rem;
            white-space: pre-wrap;
        }
        .source-link {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
        }
        #loading-indicator {
            padding: 0.5rem;
            text-align: center;
            color: #9ca3af;
        }
        .ai-message p, .ai-message ul, .ai-message ol, .ai-message strong {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .image-container {
            margin-top: 1rem;
            text-align: center;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            overflow: hidden;
            background-color: #fff;
        }
        .generated-image {
            max-width: 100%;
            height: auto;
            display: block;
            /* Zabezpe캜칤, 쬰 16:9 obr치zok sa v kontajneri zobraz칤 spr치vne bez skreslenia */
            aspect-ratio: 16 / 9; 
            object-fit: contain; 
        }
        /* Respons칤vny layout tla캜idiel */
        .button-group {
            display: flex;
            gap: 0.75rem;
        }
        @media (max-width: 640px) {
            .button-group {
                flex-direction: column; 
            }
            .button-group button {
                width: 100%;
            }
        }
        
        /* 맗ecifick칳 코t칳l pre nevidite쬹칳 input[file], ktor칳 je umiestnen칳 nad vizu치lnym tla캜idlom */
        #image-upload-wrapper input[type="file"] {
            /* Skrytie predvolen칠ho vzh쬬du */
            opacity: 0;
            /* Zabezpe캜칤, 쬰 zaber치 cel칰 plochu vizu치lneho tla캜idla pod n칤m */
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 10; 
        }
    </style>
</head>
<body>

<!-- 3D Canvas pre dynamick칠 pozadie -->
<canvas id="bg-canvas"></canvas>

<div id="chat-container">
    <!-- Chat Header -->
    <header class="chat-header p-4 text-white text-center rounded-t-xl shadow-lg">
        <h1 class="text-xl font-bold">游눫 ChatSlovak AI Pokro캜il칳 V5 PRO (Image-to-Image)</h1>
        <p class="text-sm text-gray-400">**Nov치 funkcia:** Nahrajte obr치zok pre jeho 칰pravu pomocou popisu, alebo nechajte pole pr치zdne pre generovanie od z치kladu.</p>
        <!-- INDIK츼TOR STAVU LIMITU (Kontrola je lok치lna cez localStorage, NIE cez datab치zu Firebase) -->
        <span id="limit-status" class="text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-indigo-700/50">
            Na캜칤tavam limit...
        </span>
    </header>

    <!-- Messages Area -->
    <div id="messages">
        <!-- 칔vodn치 spr치va s upraven칳m form치tovan칤m -->
        <div class="message-bubble ai-message">
            <p>Vitaj! Model bol aktualizovan칳 pre **Image-to-Image** 칰pravy. Teraz m칪쬰te nahra콘 vlastn칳 obr치zok a pomocou textov칠ho popisu ho necha콘 pretransformova콘. Pre 칰pravu **nahrajte s칰bor** a potom kliknite na **Generova콘 Obr치zok**.</p>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="hidden">
        <div class="animate-pulse">Rozm칳코쬬m...</div>
    </div>

    <!-- Input Form s troma tla캜idlami -->
    <form id="chat-form" class="p-4 chat-footer">
        
        <!-- NOV칄 UMIESTNENIE: Sekcia pre n치h쬬d a status (teraz hore) -->
        <div class="flex items-center gap-2 mb-3">
             <div id="image-preview" class="hidden h-16 w-16 rounded-lg overflow-hidden border-2 border-indigo-400 p-1 bg-white flex-shrink-0">
                <img id="preview-img" class="object-cover w-full h-full" alt="N치h쬬d nahran칠ho obr치zku">
            </div>
             <p id="image-status" class="text-xs text-gray-400">Popis pre 칰pravu (alebo generovanie) zadajte dole.</p>
        </div>

        <div class="flex space-x-3">
            <input type="text" id="user-input" placeholder="Zadajte popis pre generovanie alebo 칰pravu..." required class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            
            <div class="button-group">
                <!-- Tla캜idlo pre nahr치vanie s칰boru (teraz ako prv칠 tla캜idlo v skupine) -->
                <div id="image-upload-wrapper" class="relative min-w-max">
                    <input type="file" id="image-upload" accept="image/png, image/jpeg">
                    <!-- Tla캜idlo s vizu치lnym 코t칳lom (len vizu치l) -->
                    <button type="button" id="upload-visual-button" class="bg-purple-600 text-white p-3 rounded-lg hover:bg-purple-700 transition duration-150 flex items-center justify-center min-w-max h-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
                        </svg>
                        <span id="upload-text">Nahra콘 S칰bor</span>
                    </button>
                </div>

                <!-- Tla캜idlo pre generovanie obr치zka -->
                <button type="button" id="send-image-button" class="bg-indigo-600 text-white p-3 rounded-lg hover:bg-indigo-700 transition duration-150 flex items-center justify-center disabled:bg-indigo-400 min-w-max">
                    Generova콘 Obr치zok
                </button>
                
                <!-- Tla캜idlo pre chat -->
                <button type="submit" id="send-chat-button" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-150 flex items-center justify-center disabled:bg-blue-400 min-w-max">
                    Odosla콘
                </button>
            </div>
        </div>
    </form>
</div>

<!-- Kni쬹ice pre pokro캜il칰 funk캜nos콘 a 3D grafiku -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 3D Background Initialization (Three.js) ---
    let scene, camera, renderer, discoBall;
    let discoLights = [];
    const lightColors = [0xff00ff, 0x00ffff, 0xffff00]; 
    const canvas = document.getElementById('bg-canvas');
    let mouseX = 0, mouseY = 0;

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000); 
        camera.position.z = 200;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); 
        renderer.setSize(window.innerWidth, window.innerHeight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        scene.add(ambientLight);

        const ballGeometry = new THREE.SphereGeometry(40, 64, 32);
        const ballMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            specular: 0xffffff, 
            shininess: 100, 
            reflectivity: 0.9,
        });
        discoBall = new THREE.Mesh(ballGeometry, ballMaterial);
        scene.add(discoBall);

        const lightIntensity = 2;
        const lightDistance = 200;
        
        // Vytvorenie a umiestnenie dynamick칳ch svetiel (PointLights)
        const lightOrbitRadius = 150;
        lightColors.forEach((colorHex, index) => {
            const pointLight = new THREE.PointLight(colorHex, lightIntensity, lightDistance);
            // Po캜iato캜n칠 umiestnenie v kruhu
            pointLight.position.x = lightOrbitRadius * Math.cos(index * Math.PI * 2 / 3);
            pointLight.position.y = lightOrbitRadius * Math.sin(index * Math.PI * 2 / 3);
            pointLight.position.z = 0;
            scene.add(pointLight);
            discoLights.push(pointLight);
        });
        
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onDocumentMouseMove(event) {
        // Nastavuje poz칤ciu my코i normalizovan칰 k stredu obrazovky
        mouseX = (event.clientX - window.innerWidth / 2) * 0.2;
        mouseY = (event.clientY - window.innerHeight / 2) * 0.2;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate3D() {
        requestAnimationFrame(animate3D);

        const time = Date.now() * 0.0002;
        
        // Rot치cia diskogu쬰
        discoBall.rotation.y += 0.005; 
        discoBall.rotation.x += 0.002;

        const orbitRadius = 150;
        // Anim치cia svetiel
        discoLights.forEach((light, index) => {
            const angle = time * (index + 1) * 0.5;
            light.position.x = orbitRadius * Math.cos(angle + index * 1.5);
            light.position.z = orbitRadius * Math.sin(angle + index * 1.5);
            light.position.y = 50 * Math.sin(time + index); // Pohyb hore/dole
        });

        // Pohyb kamery pod쬬 my코i pre jemn칳 paralax efekt
        camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.y += (-mouseY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        renderer.render(scene, camera);
    }

    // --- Rate Limiting Configuration ---
    const MAX_MESSAGES_PER_HOUR = 30; 
    const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; 
    const STORAGE_KEY = 'chatSlovakMessageTimestamps';

    /** * Aktualizuje UI element s inform치ciou o zost치vaj칰com limite a vracia zost치vaj칰ce spr치vy. */
    function updateLimitStatusDisplay(currentTimestamps) {
        const now = Date.now();
        const recentTimestamps = currentTimestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        const messagesSent = recentTimestamps.length;
        const messagesRemaining = MAX_MESSAGES_PER_HOUR - messagesSent;

        const limitStatusElement = document.getElementById('limit-status');
        
        if (messagesRemaining <= 0) {
            const timeUntilResetMs = recentTimestamps.length > 0 
                ? RATE_LIMIT_WINDOW_MS - (now - recentTimestamps.sort((a, b) => a - b)[0])
                : 0; 
            
            const minutes = Math.floor(timeUntilResetMs / 60000);
            const seconds = Math.floor((timeUntilResetMs % 60000) / 1000);
            
            limitStatusElement.textContent = `Limit VY캛ERPAN칗. Reset za ${minutes}m ${seconds}s`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-red-700/70";
            return 0;
        } else {
            limitStatusElement.textContent = `Zost치va: ${messagesRemaining} z ${MAX_MESSAGES_PER_HOUR} spr치v/h`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-green-600/70";
            return messagesRemaining;
        }
    }

    /**
     * Kontroluje a aplikuje limit po캜tu spr치v pomocou localStorage.
     * @returns {boolean} True, ak je povolen칠 odosla콘 spr치vu.
     */
    function checkAndApplyRateLimit() {
        const now = Date.now();
        let timestamps = [];
        
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                timestamps = JSON.parse(stored);
                if (!Array.isArray(timestamps)) {
                    timestamps = [];
                }
            }
        } catch (e) {
            console.error("Chyba pri 캜칤tan칤 localStorage:", e);
            timestamps = [];
        }

        let recentTimestamps = timestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        const messagesRemaining = updateLimitStatusDisplay(recentTimestamps);

        if (messagesRemaining > 0) {
            recentTimestamps.push(now);
            
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(recentTimestamps));
            } catch (e) {
                console.error("Chyba pri z치pise do localStorage:", e);
            }
            
            updateLimitStatusDisplay(recentTimestamps); 
            return true; 
        } else {
            return false;
        }
    }

    // --- Text-to-Speech (TTS) Functionality ---
    const synth = window.speechSynthesis;
    let voices = [];

    function populateVoiceList() {
        voices = synth.getVoices();
    }

    if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = populateVoiceList;
    } else {
        populateVoiceList(); 
    }
    
    function speakText(text) {
        if (!synth || !text) return;
        
        if (synth.speaking) {
            synth.cancel();
        }

        const cleanText = text.replace(/\*\*/g, '').replace(/###\s*/g, ''); 
        const utterance = new SpeechSynthesisUtterance(cleanText);

        let selectedVoice = voices.find(voice => voice.lang.startsWith('sk-SK'));
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.name.includes('Google') && voice.lang.startsWith('en'));
        }
        if (!selectedVoice) {
            selectedVoice = voices[0];
        }

        if (selectedVoice) {
            utterance.voice = selectedVoice;
            utterance.lang = selectedVoice.lang;
        } else {
            utterance.lang = 'sk-SK'; 
        }

        utterance.rate = 1.0; 
        utterance.pitch = 1.0; 

        synth.speak(utterance);
    }


    // --- API Configuration and Global Variables ---

    const apiKey = "AIzaSyAzWkdCBiqlrFZODs2zEichlIWe68Wo2eI"; 
    const apiUrlBase = "https://generativelanguage.googleapis.com/v1beta/models/";
    
    // Konfigur치cia pre text (Gemini 2.5 Pro)
    const textModelName = 'gemini-2.5-pro'; 
    const textApiUrl = `${apiUrlBase}${textModelName}:generateContent?key=${apiKey}`;

    // Konfigur치cia pre obr치zky (teraz Image-to-Image / Edit치cia)
    const imageModelName = 'gemini-2.5-flash-image-preview'; // ZMENEN칄 pre Image-to-Image/Edit치ciu
    const imageApiUrl = `${apiUrlBase}${imageModelName}:generateContent?key=${apiKey}`; // ZMENEN칄 - pou쮂셨a generateContent
    
    // Glob치lne pre Base64 d치t a MIME type nahran칠ho obr치zku
    let uploadedImageBase64 = null;
    let uploadedImageMimeType = null;

    const systemInstruction = {
        parts: [{ 
            text: "Si 코pi캜kov칳 analytik, strat칠g a vedeck칳 konzultant. Tvojou 칰lohou je spracov치va콘 mimoriadne zlo쬴t칠, multi-disciplin치rne ot치zky. Tvoje odpovede musia by콘 h컄bkov칠, syntetick칠, logicky 코trukt칰rovan칠 (napr. s pou쬴t칤m o캜칤slovan칳ch bodov, odsekov alebo zoznamov) a musia preukazova콘 pokro캜il칠 kritick칠 myslenie. Vyhni sa zbyto캜n칠mu tu캜n칠mu p칤smu (markdown **), aby bol hlasov칳 v칳stup plynulej코칤. V쬯y pou쬴 Google Search na overenie a poskytnutie aktu치lnych, faktick칳ch inform치ci칤 pre komplexn칠 t칠my, ak si to ot치zka vy쬬duje. Odpovedaj v칳hradne v sloven캜ine." 
        }]
    };

    let chatHistory = [];
    const messagesDiv = document.getElementById('messages');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('user-input');
    const sendChatButton = document.getElementById('send-chat-button');
    const sendImageButton = document.getElementById('send-image-button');
    const loadingIndicator = document.getElementById('loading-indicator');
    const imageUploadInput = document.getElementById('image-upload');
    const imagePreviewDiv = document.getElementById('image-preview');
    const previewImg = document.getElementById('preview-img');
    const imageStatus = document.getElementById('image-status');
    const uploadText = document.getElementById('upload-text');


    // --- Utility Functions ---

    function delay(attempt) {
        const baseDelay = 1000;
        const maxDelay = 16000;
        const currentDelay = Math.min(maxDelay, baseDelay * Math.pow(2, attempt - 1));
        return new Promise(resolve => setTimeout(resolve, currentDelay));
    }

    // --- UI Functions ---

    function displayMessage(text, sender, sources = []) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender === 'user' ? 'user-message' : 'ai-message'}`;
        
        let formattedText;
        if (typeof marked !== 'undefined') {
            formattedText = marked.parse(text); 
        } else {
            formattedText = `<p>${text.replace(/\n/g, '<br>')}</p>`; 
        }
        
        bubble.innerHTML = formattedText;

        if (sender === 'ai' && sources.length > 0) {
            const sourcesList = document.createElement('div');
            sourcesList.className = "mt-2 pt-2 border-t border-gray-300 text-xs";
            sourcesList.innerHTML = `<strong class="text-gray-600">Zdroje:</strong>`;
            
            sources.slice(0, 3).forEach((source, index) => {
                if (source.uri && source.title) {
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.target = "_blank";
                    link.className = "source-link hover:text-blue-600";
                    link.textContent = `${index + 1}. ${source.title}`;
                    sourcesList.appendChild(link);
                }
            });
            bubble.appendChild(sourcesList);
        }

        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function displayImage(base64Data, prompt, isModification) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ai-message w-full max-w-lg mx-auto`;
        
        const imageContainer = document.createElement('div');
        imageContainer.className = 'image-container';

        const image = document.createElement('img');
        image.src = `data:image/png;base64,${base64Data}`;
        image.alt = `Generovan칳 obr치zok: ${prompt}`;
        image.className = 'generated-image';

        const downloadLink = document.createElement('a');
        downloadLink.href = image.src;
        downloadLink.download = `obrazok_16x9_${Date.now()}.png`; 
        downloadLink.className = 'block w-full bg-blue-600 text-white p-2 text-center hover:bg-blue-700 transition duration-150 rounded-b-lg';
        downloadLink.textContent = 'Stiahnu콘 obr치zok (vysok치 kvalita)';

        const description = document.createElement('p');
        description.className = 'text-xs text-gray-500 p-2 italic';
        description.textContent = isModification 
            ? `Upraven칳 obr치zok (16:9) na z치klade popisu: "${prompt}"`
            : `Generovan칳 obr치zok (16:9) na z치klade popisu: "${prompt}"`;


        imageContainer.appendChild(image);
        imageContainer.appendChild(downloadLink);
        
        bubble.appendChild(description);
        bubble.appendChild(imageContainer);


        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        speakText(isModification ? "Obr치zok bol 칰spe코ne upraven칳 a je pripraven칳 na stiahnutie." : "Obr치zok bol 칰spe코ne vygenerovan칳 a je pripraven칳 na stiahnutie.");
    }

    function setLoading(isLoading, isImage = false) {
        sendChatButton.disabled = isLoading;
        sendImageButton.disabled = isLoading;
        // Tie zneakt칤vni vizu치lne tla캜idlo nahr치vania s칰boru
        const uploadVisualButton = document.getElementById('upload-visual-button'); 
        if (uploadVisualButton) {
            uploadVisualButton.disabled = isLoading;
        }
        input.disabled = isLoading;
        imageUploadInput.disabled = isLoading;
        loadingIndicator.classList.toggle('hidden', !isLoading);
        
        loadingIndicator.querySelector('div').textContent = isLoading 
            ? (isImage ? 'Generujem/Upravujem obr치zok...' : 'Rozm칳코쬬m...')
            : '';
    }

    // --- Core API Logic ---

    /** Generuje alebo upravuje obr치zok pomocou gemini-2.5-flash-image-preview. */
    async function generateImageFromPrompt(userPrompt) {
        
        if (!checkAndApplyRateLimit()) {
             return; 
        }

        const isModification = uploadedImageBase64 !== null;
        setLoading(true, true); 

        // In코trukcia pre model
        const promptInstruction = isModification 
            ? "Generate a new image based on the provided input image, guided by this detailed instruction. Focus on photorealism and artistic quality:" 
            : "Highly detailed, photorealistic 16:9 scene, non-commercial and generic style. Focus solely on the description:";
        
        const imagePrompt = `${promptInstruction} "${userPrompt}".`;

        // Pr칤prava obsahu pre payload
        const contentsParts = [{ text: imagePrompt }];
        
        // Ak bol nahran칳 obr치zok, prid치me ho do payloadu
        if (uploadedImageBase64 && uploadedImageMimeType) {
            contentsParts.push({
                inlineData: {
                    mimeType: uploadedImageMimeType,
                    data: uploadedImageBase64
                }
            });
        }

        const payload = {
            contents: [{
                role: "user",
                parts: contentsParts
            }],
            generationConfig: {
                responseModalities: ['TEXT', 'IMAGE'],
                imageGenerationConfig: {
                    numberOfImages: 1,
                    aspectRatio: "16:9",
                }
            },
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                // Pou쬴tie imageApiUrl (gemini-2.5-flash-image-preview)
                const response = await fetch(imageApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    
                    if (response.status === 400) {
                        errorMessage = `Chyba 400: V치코 popis je pravdepodobne v rozpore s bezpe캜nostn칳mi pravidlami AI (napr. explicitn칳 obsah, autorsk칠 pr치va, nevhodn치 t칠ma). Sk칰ste in칳, menej kontroverzn칳 popis.`;
                    } else if (response.status === 429) {
                        errorMessage = `Chyba 429: Prekro캜en치 kv칩ta. Sk칰ste to nesk칪r.`;
                    } else {
                         try {
                             const errorBody = await response.json();
                             if (errorBody && errorBody.error && errorBody.error.message) {
                                 errorMessage = `API Chyba ${response.status}: ${errorBody.error.message}`;
                             }
                        } catch(e) { /* ignore json parse error */ }
                    }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                
                // Extrahovanie Base64 d치t z odpovede generateContent
                const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                
                if (base64Data) {
                    displayImage(base64Data, userPrompt, isModification); 
                    
                    // Po 칰spe코nom vygenerovan칤 obr치zka resetujeme stav nahr치vania s칰boru
                    if (isModification) {
                        uploadedImageBase64 = null;
                        uploadedImageMimeType = null;
                        imagePreviewDiv.classList.add('hidden');
                        imageUploadInput.value = ''; // Resetuje file input
                        imageStatus.textContent = "Nahran칳 obr치zok bol spracovan칳. Nahrajte nov칳 pre 캞al코iu 칰pravu.";
                        imageStatus.className = 'text-xs text-gray-400';
                        uploadText.textContent = 'Nahra콘 S칰bor';
                    }
                    
                    break;
                } else {
                    // Fallback pre textov칰 odpove캞, ak obr치zok nie je k dispoz칤cii
                    const aiText = result?.candidates?.[0]?.content?.parts?.find(p => p.text)?.text || "AI neposkytla 쬴adnu obr치zkov칰 odpove캞.";
                    displayMessage(aiText, 'ai');
                    break; 
                }
            } catch (error) {
                console.error("Chyba po캜as volania Image API:", error);
                if (attempt === maxRetries) {
                    displayMessage(`KRITICK츼 CHYBA po ${maxRetries} pokusoch: ${error.message}`, 'ai');
                }
            }
        }
        setLoading(false);
    }
    
    /** Spracuje odoslanie textovej chatovej ot치zky. (Bezo zmeny) */
    async function sendChatQuery(userQuery) {
        
        if (!checkAndApplyRateLimit()) {
            return; 
        }

        displayMessage(userQuery, 'user');
        input.value = '';

        chatHistory.push({ role: "user", parts: [{ text: userQuery }] });
        setLoading(true, false); 

        const payload = {
            contents: chatHistory,
            tools: [{ "google_search": {} }],
            systemInstruction: systemInstruction,
            generationConfig: {
                temperature: 0.7, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(textApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch (e) {
                        errorMessage = `HTTP chyba so statusom ${response.status}.`;
                    }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const aiText = candidate.content.parts[0].text;
                    
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    displayMessage(aiText, 'ai', sources);
                    speakText(aiText); // Volanie TTS
                    
                    break; 

                } else {
                    displayMessage("AI neposkytla 쬴adnu odpove캞. (Pr치zdna odpove캞 od modelu)", 'ai');
                }
            } catch (error) {
                console.error("Chyba po캜as volania API:", error);
                
                if (attempt === maxRetries) {
                    const errorMessage = `Nastala kritick치 chyba pri komunik치cii s AI po ${maxRetries} pokusoch. (${error.message})`;
                    displayMessage(errorMessage, 'ai');
                }
            }
        }

        setLoading(false);
    }
    
    // --- Spustenie aplik치cie a event listenery ---

    window.onload = function () {
        init3D();
        animate3D();
        checkAndApplyRateLimit(); 
        
        // Listener pre nahr치vanie obr치zka
        imageUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            
            const initialUploadText = 'Nahra콘 S칰bor';
            const changeUploadText = 'Nahran칠! Zmeni콘 S칰bor';

            if (file) {
                if (!file.type.startsWith('image/')) {
                    imageStatus.textContent = "Nahran칳 s칰bor nie je obr치zok. Sk칰ste PNG alebo JPEG.";
                    imageStatus.className = 'text-xs text-red-400';
                    uploadedImageBase64 = null;
                    imagePreviewDiv.classList.add('hidden');
                    uploadText.textContent = initialUploadText;
                    return;
                }
                
                // Max 4MB file size limit
                if (file.size > 4 * 1024 * 1024) {
                    imageStatus.textContent = "S칰bor je pr칤li코 ve쬶칳 (max 4MB).";
                    imageStatus.className = 'text-xs text-red-400';
                    uploadedImageBase64 = null;
                    imagePreviewDiv.classList.add('hidden');
                    uploadText.textContent = initialUploadText;
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Pre Base64, extrahujeme len d치ta po 캜iarke
                    const base64String = e.target.result.split(',')[1];
                    uploadedImageBase64 = base64String;
                    uploadedImageMimeType = file.type;

                    previewImg.src = e.target.result;
                    imagePreviewDiv.classList.remove('hidden');
                    imageStatus.textContent = `Obr치zok nahran칳: ${file.name}. Popis sl칰쬴 ako 칰prava.`;
                    imageStatus.className = 'text-xs text-green-400';
                    uploadText.textContent = changeUploadText;
                };
                reader.readAsDataURL(file);
            } else {
                uploadedImageBase64 = null;
                uploadedImageMimeType = null;
                imagePreviewDiv.classList.add('hidden');
                imageStatus.textContent = "Popis pre 칰pravu (alebo generovanie) zadajte dole.";
                imageStatus.className = 'text-xs text-gray-400';
                uploadText.textContent = initialUploadText;
            }
        });


        // Listener pre tla캜idlo CHAT (Odosla콘)
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const userQuery = input.value.trim();
            if (!userQuery) return;
            
            if (!apiKey) {
                displayMessage("CHYBA: API k쮂줷 nie je nastaven칳. (Nedostato캜n치 autoriz치cia)", 'ai');
                return;
            }
            sendChatQuery(userQuery);
        });

        // Listener pre tla캜idlo OBR츼ZOK (Generova콘 Obr치zok)
        sendImageButton.addEventListener('click', async () => {
            const userPrompt = input.value.trim();
            
            if (!userPrompt) {
                displayMessage("Pros칤m, zadajte popis obr치zku, ktor칳 chcete vygenerova콘 alebo pou쬴콘 na 칰pravu, do textov칠ho po쬬.", 'ai');
                return;
            }

            if (!apiKey) {
                displayMessage("CHYBA: API k쮂줷 nie je nastaven칳. (Nedostato캜n치 autoriz치cia)", 'ai');
                return;
            }

            // Zobrazenie promptu ako spr치vy
            const isModification = uploadedImageBase64 !== null;
            const actionText = isModification ? "Po쬴adavka na 칰pravu" : "Po쬴adavka na generovanie";
            displayMessage(`${actionText}: "${userPrompt}"`, 'user');
            input.value = '';
            
            await generateImageFromPrompt(userPrompt);
        });


        // Pre캜칤tanie 칰vodnej spr치vy po na캜칤tan칤 hlasov
        const initialMessageText = "Vitaj! Model bol aktualizovan칳 pre Image-to-Image 칰pravy. Teraz m칪쬰te nahra콘 vlastn칳 obr치zok a pomocou textov칠ho popisu ho necha콘 pretransformova콘. Pre 칰pravu nahrajte s칰bor a potom kliknite na Generova콘 Obr치zok.";
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = () => {
                populateVoiceList();
                if (messagesDiv.children.length === 1) { 
                     speakText(initialMessageText);
                }
            };
        } else {
            setTimeout(() => {
                if (messagesDiv.children.length === 1) { 
                     speakText(initialMessageText);
                }
            }, 500);
        }
    }

</script>
</body>
</html>













