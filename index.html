<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatSlovak AI Pokroƒçil√Ω V5 Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f003e; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            position: relative; 
            overflow: hidden;
        }
        #bg-canvas {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; 
            display: block;
        }
        #chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            
            /* SKLENEN√ù EFEKT */
            background-color: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(15px); 
            -webkit-backdrop-filter: blur(15px); 
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); 
            overflow: hidden;
            z-index: 10; 
        }
        
        .chat-header {
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-footer {
            background-color: rgba(255, 255, 255, 0.05); 
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .user-message {
            background-color: #3b82f6; 
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }
        .ai-message {
            background-color: rgba(255, 255, 255, 0.85); 
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.25rem;
            white-space: pre-wrap;
        }
        .source-link {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
        }
        #loading-indicator {
            padding: 0.5rem;
            text-align: center;
            color: #9ca3af;
        }
        .ai-message p, .ai-message ul, .ai-message ol, .ai-message strong {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
    </style>
</head>
<body>

<!-- 3D Canvas pre dynamick√© pozadie -->
<canvas id="bg-canvas"></canvas>

<div id="chat-container">
    <!-- Chat Header -->
    <header class="chat-header p-4 text-white text-center rounded-t-xl shadow-lg">
        <h1 class="text-xl font-bold">üí¨ ChatSlovak AI Pokroƒçil√Ω V5 PRO</h1>
        <p class="text-sm text-gray-400">Na≈°a spoloƒçnos≈• GAMEPLA631: P√Ωtajte sa na veƒæmi zlo≈æit√© t√©my. Pou≈æ√≠va overen√© d√°ta (Grounding).</p>
        <!-- INDIK√ÅTOR STAVU LIMITU (Kontrola je lok√°lna cez localStorage, NIE cez datab√°zu Firebase) -->
        <span id="limit-status" class="text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-indigo-700/50">
            Naƒç√≠tavam limit...
        </span>
    </header>

    <!-- Messages Area -->
    <div id="messages">
        <!-- √övodn√° spr√°va s upraven√Ωm form√°tovan√≠m -->
        <div class="message-bubble ai-message">
            <p>Vitaj v ChatSlovak AI Pokroƒçil√Ω V5 PRO! Model bol teraz aktualizovan√Ω na najvy≈°≈°iu √∫rove≈à v√Ωkonu, vƒèaka ƒçomu zvl√°dne aj tie najkomplexnej≈°ie ot√°zky. Aplik√°cia nepou≈æ√≠va ≈æiadnu datab√°zu; limit je kontrolovan√Ω lok√°lne vo va≈°om prehliadaƒçi.</p>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="hidden">
        <div class="animate-pulse">Rozm√Ω≈°ƒæam Pre lep≈°iu odpoveƒè ƒçakaj 90s</div>
    </div>

    <!-- Input Form -->
    <form id="chat-form" class="p-4 border-t border-gray-200 chat-footer">
        <div class="flex space-x-3">
            <input type="text" id="user-input" placeholder="Zadajte svoju zlo≈æit√© po≈æiadavku..." required class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            <button type="submit" id="send-button" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-150 flex items-center justify-center disabled:bg-blue-400">
                Odosla≈•
            </button>
        </div>
    </form>
</div>

<!-- Kni≈ænice pre pokroƒçil√∫ funkƒçnos≈• a 3D grafiku -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 3D Background Initialization (Three.js) ---
    let scene, camera, renderer, discoBall;
    let discoLights = [];
    const lightColors = [0xff00ff, 0x00ffff, 0xffff00]; 
    const canvas = document.getElementById('bg-canvas');
    let mouseX = 0, mouseY = 0;

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000); 
        camera.position.z = 200;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); 
        renderer.setSize(window.innerWidth, window.innerHeight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        scene.add(ambientLight);

        const ballGeometry = new THREE.SphereGeometry(40, 64, 32);
        const ballMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            specular: 0xffffff, 
            shininess: 100, 
            reflectivity: 0.9,
        });
        discoBall = new THREE.Mesh(ballGeometry, ballMaterial);
        scene.add(discoBall);

        const lightIntensity = 2;
        const lightDistance = 200;
        const lightOrbitRadius = 150;

        lightColors.forEach((colorHex, index) => {
            const pointLight = new THREE.PointLight(colorHex, lightIntensity, lightDistance);
            pointLight.position.x = lightOrbitRadius * Math.cos(index * Math.PI * 2 / 3);
            pointLight.position.y = lightOrbitRadius * Math.sin(index * Math.PI * 2 / 3);
            pointLight.position.z = 0;
            scene.add(pointLight);
            discoLights.push(pointLight);
        });
        
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onDocumentMouseMove(event) {
        mouseX = (event.clientX - window.innerWidth / 2) * 0.2;
        mouseY = (event.clientY - window.innerHeight / 2) * 0.2;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate3D() {
        requestAnimationFrame(animate3D);

        const time = Date.now() * 0.0002;
        
        discoBall.rotation.y += 0.005; 
        discoBall.rotation.x += 0.002;

        const orbitRadius = 150;
        discoLights.forEach((light, index) => {
            const angle = time * (index + 1) * 0.5;
            light.position.x = orbitRadius * Math.cos(angle + index * 1.5);
            light.position.z = orbitRadius * Math.sin(angle + index * 1.5);
            light.position.y = 50 * Math.sin(time + index); 
        });

        camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.y += (-mouseY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        renderer.render(scene, camera);
    }

    // --- Rate Limiting Configuration ---
    // T√°to ƒças≈• pou≈æ√≠va LOK√ÅLNE √∫lo≈æisko (localStorage), NIE datab√°zu Firebase.
    const MAX_MESSAGES_PER_HOUR = 30; 
    const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; 
    const STORAGE_KEY = 'chatSlovakMessageTimestamps';

    /** * Aktualizuje UI element s inform√°ciou o zost√°vaj√∫com limite a vracia zost√°vaj√∫ce spr√°vy. */
    function updateLimitStatusDisplay(currentTimestamps) {
        const now = Date.now();
        
        // Filtruje ƒçasov√© peƒçiatky len v r√°mci poslednej hodiny
        const recentTimestamps = currentTimestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        
        const messagesSent = recentTimestamps.length;
        const messagesRemaining = MAX_MESSAGES_PER_HOUR - messagesSent;

        const limitStatusElement = document.getElementById('limit-status');
        
        if (messagesRemaining <= 0) {
            const timeUntilResetMs = recentTimestamps.length > 0 
                ? RATE_LIMIT_WINDOW_MS - (now - recentTimestamps[0])
                : 0; 
            
            const minutes = Math.floor(timeUntilResetMs / 60000);
            const seconds = Math.floor((timeUntilResetMs % 60000) / 1000);
            
            limitStatusElement.textContent = `Limit VYƒåERPAN√ù. Reset za ${minutes}m ${seconds}s`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-red-700/70";
            return 0;
        } else {
            limitStatusElement.textContent = `Zost√°va: ${messagesRemaining} z ${MAX_MESSAGES_PER_HOUR} spr√°v/h`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-green-600/70";
            return messagesRemaining;
        }
    }


    /**
     * Kontroluje a aplikuje limit poƒçtu spr√°v pomocou localStorage.
     * @returns {boolean} True, ak je povolen√© odosla≈• spr√°vu.
     */
    function checkAndApplyRateLimit() {
        const now = Date.now();
        let timestamps = [];
        
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                timestamps = JSON.parse(stored);
                if (!Array.isArray(timestamps)) {
                    timestamps = [];
                }
            }
        } catch (e) {
            console.error("Chyba pri ƒç√≠tan√≠ localStorage:", e);
            timestamps = [];
        }

        let recentTimestamps = timestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);

        const messagesRemaining = updateLimitStatusDisplay(recentTimestamps);

        if (messagesRemaining > 0) {
            recentTimestamps.push(now);
            
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(recentTimestamps));
            } catch (e) {
                console.error("Chyba pri z√°pise do localStorage:", e);
            }
            
            updateLimitStatusDisplay(recentTimestamps); 
            return true; 
        } else {
            return false;
        }
    }

    // --- Text-to-Speech (TTS) Functionality ---
    const synth = window.speechSynthesis;
    let voices = [];

    function populateVoiceList() {
        voices = synth.getVoices();
    }

    // Naƒç√≠tanie dostupn√Ωch hlasov
    if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = populateVoiceList;
    } else {
        populateVoiceList(); 
    }
    
    function speakText(text) {
        if (!synth || !text) return;
        
        // Zastavenie predo≈°l√©ho hovorenia
        if (synth.speaking) {
            synth.cancel();
        }

        // Odstr√°nenie znaƒçiek Markdown (tuƒçn√© p√≠smo) pre lep≈°√≠ z√°≈æitok z hovorenia
        const cleanText = text.replace(/\*\*/g, '').replace(/###\s*/g, ''); 

        const utterance = new SpeechSynthesisUtterance(cleanText);

        // 1. Prioritne n√°jdeme slovensk√Ω hlas
        let selectedVoice = voices.find(voice => voice.lang.startsWith('sk-SK'));

        // 2. Ak slovensk√Ω nie je, hƒæad√°me nejak√Ω pekn√Ω anglick√Ω (ƒçasto Google)
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.name.includes('Google') && voice.lang.startsWith('en'));
        }
        
        // 3. Fallback na prv√Ω dostupn√Ω hlas
        if (!selectedVoice) {
            selectedVoice = voices[0];
        }

        // Aplik√°cia vybran√©ho hlasu
        if (selectedVoice) {
            utterance.voice = selectedVoice;
            utterance.lang = selectedVoice.lang;
        } else {
             // Nastav√≠me aspo≈à slovensk√Ω jazyk, aby prehliadaƒç vybral default SK/CZ hlas
            utterance.lang = 'sk-SK'; 
        }

        // Pr√≠jemn√© nastavenie r√Ωchlosti a v√Ω≈°ky
        utterance.rate = 1.0; 
        utterance.pitch = 1.0; 

        synth.speak(utterance);
    }


    // --- API Configuration and Global Variables ---

    const apiKey = "AIzaSyAzWkdCBiqlrFZODs2zEichlIWe68Wo2eI"; 
    const apiUrlBase = "https://generativelanguage.googleapis.com/v1beta/models/";
    
    // Pou≈æ√≠vame Gemini 2.5 PRO pre maxim√°lny v√Ωkon.
    const modelName = 'gemini-2.5-pro'; 
    const apiUrl = `${apiUrlBase}${modelName}:generateContent?key=${apiKey}`;

    const systemInstruction = {
        parts: [{ 
            text: "Si ≈°piƒçkov√Ω analytik, strat√©g a vedeck√Ω konzultant. Tvojou √∫lohou je spracov√°va≈• mimoriadne zlo≈æit√©, multi-disciplin√°rne ot√°zky. Tvoje odpovede musia by≈• hƒ∫bkov√©, syntetick√©, logicky ≈°trukt√∫rovan√© (napr. s pou≈æit√≠m oƒç√≠slovan√Ωch bodov, odsekov alebo zoznamov) a musia preukazova≈• pokroƒçil√© kritick√© myslenie. Vyhni sa zbytoƒçn√©mu tuƒçn√©mu p√≠smu (markdown **), aby bol hlasov√Ω v√Ωstup plynulej≈°√≠. V≈ædy pou≈æi Google Search na overenie a poskytnutie aktu√°lnych, faktick√Ωch inform√°ci√≠ pre komplexn√© t√©my, ak si to ot√°zka vy≈æaduje. Odpovedaj v√Ωhradne v slovenƒçine." 
        }]
    };

    let chatHistory = [];
    const messagesDiv = document.getElementById('messages');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const loadingIndicator = document.getElementById('loading-indicator');

    // --- UI Functions ---

    function displayMessage(text, sender, sources = []) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender === 'user' ? 'user-message' : 'ai-message'}`;
        
        let formattedText;
        if (typeof marked !== 'undefined') {
            formattedText = marked.parse(text); 
        } else {
            formattedText = `<p>${text.replace(/\n/g, '<br>')}</p>`; 
        }
        
        bubble.innerHTML = formattedText;

        if (sender === 'ai' && sources.length > 0) {
            const sourcesList = document.createElement('div');
            sourcesList.className = "mt-2 pt-2 border-t border-gray-300 text-xs";
            sourcesList.innerHTML = `<strong class="text-gray-600">Zdroje:</strong>`;
            
            sources.slice(0, 3).forEach((source, index) => {
                if (source.uri && source.title) {
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.target = "_blank";
                    link.className = "source-link hover:text-blue-600";
                    link.textContent = `${index + 1}. ${source.title}`;
                    sourcesList.appendChild(link);
                }
            });
            bubble.appendChild(sourcesList);
        }

        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function setLoading(isLoading) {
        sendButton.disabled = isLoading;
        input.disabled = isLoading;
        loadingIndicator.classList.toggle('hidden', !isLoading);
    }

    // --- Core API Logic ---

    function delay(attempt) {
        const baseDelay = 1000;
        const maxDelay = 16000;
        const currentDelay = Math.min(maxDelay, baseDelay * Math.pow(2, attempt - 1));
        return new Promise(resolve => setTimeout(resolve, currentDelay));
    }

    /** Spracuje odoslanie formul√°ra a zavol√° Gemini API. */
    async function sendMessage(event) {
        event.preventDefault();
        const userQuery = input.value.trim();
        if (!userQuery) return;

        // KONTROLA AUTORIZ√ÅCIE
        if (!apiKey) {
            displayMessage("CHYBA: API kƒæ√∫ƒç nie je nastaven√Ω. (Nedostatoƒçn√° autoriz√°cia)", 'ai');
            return;
        }

        // KONTROLA LOK√ÅLNEHO LIMITU
        if (!checkAndApplyRateLimit()) {
            input.placeholder = "LIMIT VYƒåERPAN√ù! Sk√∫ste to pros√≠m nesk√¥r.";
            input.classList.add('border-red-500', 'placeholder-red-400', 'ring-2', 'ring-red-500');
            setTimeout(() => {
                input.placeholder = "Zadajte svoju zlo≈æit√© po≈æiadavku...";
                input.classList.remove('border-red-500', 'placeholder-red-400', 'ring-2', 'ring-red-500');
            }, 3000);
            input.value = ''; 
            return;
        }

        displayMessage(userQuery, 'user');
        chatHistory.push({ role: "user", parts: [{ text: userQuery }] });
        input.value = '';
        setLoading(true);

        const payload = {
            contents: chatHistory,
            tools: [{ "google_search": {} }],
            systemInstruction: systemInstruction,
            
            // Konfigur√°cia generovania
            generationConfig: {
                temperature: 0.7, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch (e) {
                        errorMessage = `HTTP chyba so statusom ${response.status}.`;
                    }

                    displayMessage(`KRITICK√ù PROBL√âM: ${errorMessage} Skontrolujte, pros√≠m, svoj API kƒæ√∫ƒç a kv√≥tu.`, 'ai');
                    
                    if (attempt < maxRetries) {
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(`Kritick√° chyba po opakovan√Ωch pokusoch: ${errorMessage}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const aiText = candidate.content.parts[0].text;
                    
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    displayMessage(aiText, 'ai', sources);
                    speakText(aiText); // Volanie TTS
                    
                    break; 

                } else {
                    displayMessage("AI neposkytla ≈æiadnu odpoveƒè. (Pr√°zdna odpoveƒè od modelu)", 'ai');
                }
            } catch (error) {
                console.error("Chyba poƒças volania API:", error);
                
                if (attempt === maxRetries) {
                    const errorMessage = `Nastala kritick√° chyba pri komunik√°cii s AI po ${maxRetries} pokusoch. (${error.message})`;
                    displayMessage(errorMessage, 'ai');
                }
            }
        }

        setLoading(false);
    }
    
    // --- Spustenie aplik√°cie ---

    window.onload = function () {
        init3D();
        animate3D();
        // Naƒç√≠ta a zobraz√≠ stav lok√°lneho limitu pri ≈°tarte
        checkAndApplyRateLimit(); 
        form.addEventListener('submit', sendMessage);

        // Preƒç√≠tanie √∫vodnej spr√°vy po naƒç√≠tan√≠ hlasov
        const initialMessageText = "Vitaj v ChatSlovak AI Pokroƒçil√Ω V5 PRO! Model bol teraz aktualizovan√Ω na najvy≈°≈°iu √∫rove≈à v√Ωkonu, vƒèaka ƒçomu zvl√°dne aj tie najkomplexnej≈°ie ot√°zky. Aplik√°cia nepou≈æ√≠va ≈æiadnu datab√°zu; limit je kontrolovan√Ω lok√°lne vo va≈°om prehliadaƒçi.";
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = () => {
                populateVoiceList();
                speakText(initialMessageText);
            };
        } else {
            // Fallback pre r√Ωchlej≈°ie prehliadaƒçe
            setTimeout(() => speakText(initialMessageText), 500);
        }
    }

</script>
</body>
</html>








