<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatSlovak AI Pokro캜il칳 V5 PRO (s Roblox Lua 3D a TTS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f003e; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            position: relative; 
            overflow: hidden;
        }
        #bg-canvas {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; 
            display: block;
        }
        #chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            
            /* SKLENEN칗 EFEKT */
            background-color: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(15px); 
            -webkit-backdrop-filter: blur(15px); 
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); 
            overflow: hidden;
            z-index: 10; 
        }
        
        .chat-header {
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-footer {
            background-color: rgba(255, 255, 255, 0.05); 
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .user-message {
            background-color: #3b82f6; 
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }
        .ai-message {
            background-color: rgba(255, 255, 255, 0.85); 
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.25rem;
            white-space: pre-wrap;
        }
        .source-link {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
        }
        #loading-indicator {
            padding: 0.5rem;
            text-align: center;
            color: #9ca3af;
        }
        .ai-message p, .ai-message ul, .ai-message ol, .ai-message strong {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        
        /* P칪vodn칳 코t칳l pre k칩dov칠 bloky v spr치vach */
        .ai-message pre {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-top: 0.75rem;
        }

        /* --- NOV칄 T칗LY PRE LUA K칍D (POD컇A VZORU) --- */
        .lua-code-wrapper {
            background-color: #1f2937; /* Tmav칠 pozadie k칩du */
            border-radius: 0.5rem;
            margin-top: 0.75rem;
            overflow: hidden;
            position: relative;
            border: 1px solid #374151; /* Jemn칳 okraj */
        }

        .lua-code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #374151; /* Hlavi캜ka k칩du */
            color: #9ca3af; /* Siv칳 text */
            font-size: 0.875rem;
        }

        .lua-code-content {
            padding: 1rem;
            color: #d1d5db; /* Svetl칳 text k칩du */
            white-space: pre; 
            overflow-x: auto;
            font-family: monospace;
            line-height: 1.4;
            font-size: 0.9rem;
            margin: 0; /* Odstr치ni okraje <pre> elementu */
        }

        .copy-button {
            background-color: #4f46e5; /* Fialovo-modr칠 tla캜idlo */
            color: white;
            padding: 0.3rem 0.75rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.15s;
            font-weight: 500;
        }
        .copy-button:hover {
            background-color: #6366f1;
        }
        /* --- KONIEC NOV칗CH T칗LOV --- */

        /* Respons칤vny layout tla캜idiel */
        .button-group {
            display: flex;
            gap: 0.75rem;
        }
        @media (max-width: 640px) {
            .button-group {
                flex-direction: column; 
            }
            .button-group button {
                width: 100%;
            }
        }
    </style>
</head>
<body>

<!-- 3D Canvas pre dynamick칠 pozadie -->
<canvas id="bg-canvas"></canvas>

<div id="chat-container">
    <!-- Chat Header -->
    <header class="chat-header p-4 text-white text-center rounded-t-xl shadow-lg">
        <h1 class="text-xl font-bold">游눫 ChatSlovak AI Pokro캜il칳 V5 PRO (Roblox Lua 3D & TTS)</h1>
        <p class="text-sm text-gray-400">**Nov치 funkcia:** Zadajte popis pre generovanie komplexn칠ho Lua k칩du 3D modelu (Roblox Command Bar).</p>
        <!-- INDIK츼TOR STAVU LIMITU -->
        <span id="limit-status" class="text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-indigo-700/50">
            Na캜칤tavam limit...
        </span>
    </header>

    <!-- Messages Area -->
    <div id="messages">
        <!-- 칔vodn치 spr치va s upraven칳m form치tovan칤m -->
        <div class="message-bubble ai-message">
            <p>Vitaj! Model bol aktualizovan칳 pre **Generovanie 3D modelov v Lua** a **Slovensk칰 synt칠zu re캜i**. Zadajte presn칳 popis modelu (napr. *detailn칳 st칤ha캜ka v retro 코t칳le*, alebo *modr치 코pir치lov치 ve쬬 so zlat칳mi prvkami*), a kliknite na **Generova콘 3D Model**, alebo po코lite be쬹칰 ot치zku. Odpove캞 bude aj pre캜칤tan치.</p>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="hidden">
        <div class="animate-pulse"></div>
    </div>

    <!-- Input Form s dvoma tla캜idlami -->
    <form id="chat-form" class="p-4 chat-footer">
        <div class="flex space-x-3">
            <input type="text" id="user-input" placeholder="Zadajte popis modelu (napr. Vesm칤rna lo캞 s 3 tryskami) alebo ot치zku..." required class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            
            <div class="button-group">
                <!-- Tla캜idlo pre generovanie 3D modelu -->
                <button type="button" id="send-3d-model-button" class="bg-purple-600 text-white p-3 rounded-lg hover:bg-purple-700 transition duration-150 flex items-center justify-center disabled:bg-purple-400 min-w-max">
                    Generova콘 3D Model
                </button>
                
                <!-- Tla캜idlo pre chat -->
                <button type="submit" id="send-chat-button" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-150 flex items-center justify-center disabled:bg-blue-400 min-w-max">
                    Odosla콘
                </button>
            </div>
        </div>
    </form>
</div>

<!-- Kni쬹ice pre pokro캜il칰 funk캜nos콘 a 3D grafiku -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 3D Background Initialization (Three.js) ---
    let scene, camera, renderer, discoBall;
    let discoLights = [];
    const lightColors = [0xff00ff, 0x00ffff, 0xffff00]; 
    const canvas = document.getElementById('bg-canvas');
    let mouseX = 0, mouseY = 0;

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000); 
        camera.position.z = 200;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); 
        renderer.setSize(window.innerWidth, window.innerHeight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        scene.add(ambientLight);

        const ballGeometry = new THREE.SphereGeometry(40, 64, 32);
        const ballMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            specular: 0xffffff, 
            shininess: 100, 
            reflectivity: 0.9,
        });
        discoBall = new THREE.Mesh(ballGeometry, ballMaterial);
        scene.add(discoBall);

        const lightIntensity = 2;
        const lightDistance = 200;
        
        // Vytvorenie a umiestnenie dynamick칳ch svetiel (PointLights)
        const lightOrbitRadius = 150;
        lightColors.forEach((colorHex, index) => {
            const pointLight = new THREE.PointLight(colorHex, lightIntensity, lightDistance);
            // Po캜iato캜n칠 umiestnenie v kruhu
            pointLight.position.x = lightOrbitRadius * Math.cos(index * Math.PI * 2 / 3);
            pointLight.position.y = lightOrbitRadius * Math.sin(index * Math.PI * 2 / 3);
            pointLight.position.z = 0;
            scene.add(pointLight);
            discoLights.push(pointLight);
        });
        
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onDocumentMouseMove(event) {
        // Nastavuje poz칤ciu my코i normalizovan칰 k stredu obrazovky
        mouseX = (event.clientX - window.innerWidth / 2) * 0.2;
        mouseY = (event.clientY - window.innerHeight / 2) * 0.2;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate3D() {
        requestAnimationFrame(animate3D);

        const time = Date.now() * 0.0002;
        
        // Rot치cia diskogu쬰
        discoBall.rotation.y += 0.005; 
        discoBall.rotation.x += 0.002;

        const orbitRadius = 150;
        // Anim치cia svetiel
        discoLights.forEach((light, index) => {
            const angle = time * (index + 1) * 0.5;
            light.position.x = orbitRadius * Math.cos(angle + index * 1.5);
            light.position.z = orbitRadius * Math.sin(angle + index * 1.5);
            light.position.y = 50 * Math.sin(time + index); // Pohyb hore/dole
        });

        // Pohyb kamery pod쬬 my코i pre jemn칳 paralax efekt
        camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.y += (-mouseY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        renderer.render(scene, camera);
    }

    // --- Rate Limiting Configuration ---
    const MAX_MESSAGES_PER_HOUR = 30; 
    const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; 
    const STORAGE_KEY = 'chatSlovakMessageTimestamps';
    
    // Glob치lna premenn치 pre 캜asova캜 resetu
    window.rateLimitTimeout = null; 

    /** * Aktualizuje UI element s inform치ciou o zost치vaj칰com limite a vracia objekt so stavom.
     * @returns {object} { remaining: number, timeUntilReset: number }
     */
    function updateLimitStatusDisplay(currentTimestamps) {
        const now = Date.now();
        // Odfiltruje len tie timestampy, ktor칠 s칰 e코te v r치mci hodinov칠ho okna.
        const recentTimestamps = currentTimestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        const messagesSent = recentTimestamps.length;
        const messagesRemaining = MAX_MESSAGES_PER_HOUR - messagesSent;

        const limitStatusElement = document.getElementById('limit-status');
        
        let timeUntilResetMs = 0;

        if (messagesRemaining <= 0) {
            // Limit VY캛ERPAN칗. Vypo캜칤tame 캜as, kedy vypr코칤 najstar코ia spr치va.
            if (recentTimestamps.length > 0) {
                // Najprv zorad칤me, aby sme na코li najstar코iu spr치vu
                const oldestTimestamp = recentTimestamps.sort((a, b) => a - b)[0];
                timeUntilResetMs = RATE_LIMIT_WINDOW_MS - (now - oldestTimestamp);
                if (timeUntilResetMs < 0) timeUntilResetMs = 0; // Ak 캜as u uplynul, nastav칤me na 0.
            }
            
            const minutes = Math.floor(timeUntilResetMs / 60000);
            const seconds = Math.floor((timeUntilResetMs % 60000) / 1000);
            
            // UI Update
            limitStatusElement.textContent = `Limit VY캛ERPAN칗. Reset za ${minutes}m ${seconds}s`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-red-700/70";
            
            return { remaining: 0, timeUntilReset: timeUntilResetMs };

        } else {
            // Limit OK
            limitStatusElement.textContent = `Zost치va: ${messagesRemaining} z ${MAX_MESSAGES_PER_HOUR} spr치v/h`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-green-600/70";
            
            return { remaining: messagesRemaining, timeUntilReset: 0 };
        }
    }

    /**
     * Kontroluje a aplikuje limit po캜tu spr치v pomocou localStorage.
     * Taktie nastavuje automatick칳 캜asova캜 resetu, ak je limit prekro캜en칳.
     * @param {boolean} apply - Ak je true, aplikuje sa nov칳 timestamp (odosiela sa spr치va).
     * @returns {boolean} True, ak je povolen칠 odosla콘 spr치vu.
     */
    function checkAndApplyRateLimit(apply = false) { 
        const now = Date.now();
        let timestamps = [];
        
        // 1. Na캜칤ta콘 a vy캜isti콘 star칠 캜asy
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                timestamps = JSON.parse(stored);
                if (!Array.isArray(timestamps)) {
                    timestamps = [];
                }
            }
        } catch (e) {
            console.error("Chyba pri 캜칤tan칤 localStorage:", e);
            timestamps = [];
        }

        let recentTimestamps = timestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        
        // 2. Skontrolova콘 limit
        const { remaining: messagesRemaining, timeUntilReset } = updateLimitStatusDisplay(recentTimestamps);

        // 3. Logika aplik치cie a monitorovania
        if (messagesRemaining > 0) {
            // Limit OK. Zru코칤me existuj칰ci 캜asova캜 (ak nejak칳 be쬬l z predch치dzaj칰ceho zlyhania)
            if (window.rateLimitTimeout) {
                clearTimeout(window.rateLimitTimeout);
                window.rateLimitTimeout = null;
            }

            if (apply) {
                // Ak sa m치 aplikova콘 (odosiela sa spr치va), prid치me nov칳 timestamp
                recentTimestamps.push(now);
                
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(recentTimestamps));
                } catch (e) {
                    console.error("Chyba pri z치pise do localStorage:", e);
                }
                // Prekresl칤me UI po pridan칤 novej spr치vy
                updateLimitStatusDisplay(recentTimestamps); 
            }
            
            return true; 
        } else {
            // Limit VY캛ERPAN칗. Nastav칤me 캜asova캜 na kontrolu, ak e코te nie je spusten칳.
            if (timeUntilReset > 0) {
                if (window.rateLimitTimeout) {
                    clearTimeout(window.rateLimitTimeout); // V쬯y vy캜ist칤me star칳, aby sme predi코li duplik치tom
                }
                
                // Nastav칤me timeout o 1 sekundu dlh코칤 ako je 캜as do resetu pre zaru캜enie uplynutia.
                window.rateLimitTimeout = setTimeout(() => {
                    window.rateLimitTimeout = null; 
                    checkAndApplyRateLimit(false); // Skontrolujeme znova bez aplik치cie timestampu
                }, timeUntilReset + 1000); 
            }
            
            return false;
        }
    }

    // --- Core API Configuration ---

    const apiKey = "AIzaSyAzWkdCBiqlrFZODs2zEichlIWe68Wo2eI"; 
    const apiUrlBase = "https://generativelanguage.googleapis.com/v1beta/models/";
    
    // Konfigur치cia pre text a 3D modely
    const textModelName = 'gemini-2.5-pro'; 
    const textApiUrl = `${apiUrlBase}${textModelName}:generateContent?key=${apiKey}`;

    // V코eobecn치 syst칠mov치 in코trukcia pre chat
    // UPRAVEN칄: Z치kaz pou쬴tia symbolu # a striktn칠 obmedzenie form치tovania len na tu캜n칳 text a zoznamy
    const systemInstructionChat = {
        parts: [{ 
            text: "Si 코pi캜kov칳 analytik a konzultant. Tvoja 칰loha je spracov치va콘 zlo쬴t칠 ot치zky. Tvoje odpovede musia by콘 h컄bkov칠, syntetick칠 a V콯DY logicky 코trukt칰rovan칠. **V쬯y pou쮂셨aj iba jednoduch칳 Markdown:** **1. Pou쮂셨aj len tu캜n칳 text (**slovo**) pre k쮂줷꼂v칠 pojmy.** **2. Pou쮂셨aj len zoznamy (odr치쬶y alebo 캜칤slovanie) pre preh쬬dn칠 body.** **D칎LE콯IT칄:** Z치sadne NIKDY nepou쮂셨aj symbol `#` (nadpisy), ani **쬴adne in칠 코peci치lne znaky pre zv칳raznenie form치tovania (ako napr. *** alebo HTML)**, okrem tu캜n칠ho textu a zoznamov. V쬯y pou쬴 Google Search na overenie a poskytnutie aktu치lnych, faktick칳ch inform치ci칤. Odpovedaj v칳hradne v sloven캜ine a bu캞 u쬴to캜n칳."
        }]
    };
    
    // Syst칠mov치 in코trukcia pre generovanie 3D Lua k칩du
    const systemInstruction3DModel = {
        parts: [{
            text: `You are an expert Roblox Lua script writer. Your task is to generate clean, self-contained Lua code for the Roblox Studio Command Bar to construct an advanced 3D model based on the user's description. The code MUST:
1.  Be runnable instantly in the Command Bar.
2.  Use basic Roblox Parts, CFrame, and Materials.
3.  Be contained in a single code block.
4.  Start with 'local model = Instance.new("Model", game.Workspace)' and ensure all created parts are parented to this model for easy deletion.
5.  Use comments sparingly, only for complex logic.
6.  The final output MUST ONLY contain the Lua code (no introductory text, explanations, or markdown fences outside the code block).`
        }]
    };

    let chatHistory = [];
    const messagesDiv = document.getElementById('messages');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('user-input');
    const sendChatButton = document.getElementById('send-chat-button');
    const send3DModelButton = document.getElementById('send-3d-model-button'); 
    const loadingIndicator = document.getElementById('loading-indicator');


    // --- Native Text-to-Speech (TTS) Functionality (Web Speech API) ---
    // Nastavenie hlasu pre nat칤vny TTS
    let selectedVoice = null;
    
    function setVoice() {
        if (typeof window.speechSynthesis === 'undefined') return;

        const voices = window.speechSynthesis.getVoices();
        
        // 1. Sk칰si n치js콘 slovensk칳 hlas
        selectedVoice = voices.find(voice => 
            voice.lang.startsWith('sk')
        );

        // 2. Ak nena코iel, sk칰si n치js콘 nejak칳 kvalitn칳 Google hlas
        if (!selectedVoice) {
             selectedVoice = voices.find(voice => voice.name.startsWith('Google') && voice.lang.startsWith('en'));
        }

        // 3. Posledn치 mo쬹os콘: ak칳ko쭀ek hlas
        if (!selectedVoice && voices.length > 0) {
            selectedVoice = voices[0];
        }

        console.log("TTS Hlas vybran칳:", selectedVoice ? selectedVoice.name : "콯iadny hlas nebol n치jden칳.");
    }
    
    // Voices may not load immediately, so attach the listener
    if (typeof window.speechSynthesis !== 'undefined') {
        setVoice(); // Sk칰si to hne캞
        window.speechSynthesis.onvoiceschanged = setVoice; // Zaru캜칤 na캜칤tanie po evente
    }

    // Funkcia prevodu textu na re캜
    async function speakText(text) {
        // Nat칤vny TTS nem치 probl칠m so zasek치van칤m v porovnan칤 s API, ale st치le ho treba povoli콘 u쮂셨ate쬽kou interakciou.
        if (typeof window.speechSynthesis === 'undefined' || !selectedVoice || !text) return;

        // Zru코칤 predch치dzaj칰ce 캜칤tanie, ak prebieha
        window.speechSynthesis.cancel();
        
        // Odstr치nenie markdown syntaxe (hlavi캜ky, tu캜n칳 text, k칩dov칠 bloky) pre 캜istej코ie 캜칤tanie
        const cleanText = text.replace(/\*\*/g, '').replace(/```lua[\s\S]*?```/g, '').replace(/###\s*/g, '').trim();

        if (cleanText.length === 0) return;

        const utterance = new SpeechSynthesisUtterance(cleanText);
        utterance.voice = selectedVoice;
        utterance.rate = 1.0; // R칳chlos콘
        utterance.pitch = 1.0; // V칳코ka
        
        window.speechSynthesis.speak(utterance);
    }


    // --- Utility Functions ---

    function delay(attempt) {
        const baseDelay = 1000;
        const maxDelay = 16000;
        const currentDelay = Math.min(maxDelay, baseDelay * Math.pow(2, attempt - 1));
        return new Promise(resolve => setTimeout(resolve, currentDelay));
    }

    /**
     * Skop칤ruje text do schr치nky a zmen칤 text tla캜idla.
     */
    function copyToClipboard(button, textToCopy) {
        // Pou쬴tie document.execCommand('copy') pre kompatibilitu v iFrame
        const textarea = document.createElement('textarea');
        textarea.value = textToCopy;
        textarea.style.position = 'fixed'; 
        textarea.style.opacity = 0;
        document.body.appendChild(textarea);
        textarea.select();
        
        try {
            const success = document.execCommand('copy');
            if (success) {
                const originalText = button.textContent;
                button.textContent = 'Skop칤rovan칠!';
                button.style.backgroundColor = '#10b981'; // Green color for success
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#4f46e5'; // Restore color
                }, 2000);
            } else {
                console.error('Kop칤rovanie zlyhalo.');
            }
        } catch (err) {
            console.error('Kop칤rovanie ne칰spe코n칠', err);
        }
        document.body.removeChild(textarea);
    }
    
    // Spr칤stupn칤 funkciu glob치lne, aby ju bolo mo쬹칠 vola콘 z dynamicky vygenerovan칠ho HTML
    window.copyToClipboard = copyToClipboard; 


    // --- UI Functions ---

    function displayMessage(text, sender, sources = []) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender === 'user' ? 'user-message' : 'ai-message'}`;
        
        let formattedText = '';
        const luaCodeMatch = text.match(/```lua\s*([\s\S]*?)```/); // Regex pre n치jdenie Lua k칩du

        if (sender === 'ai' && luaCodeMatch) {
            // --- VLASTN칄 RENDEROVANIE LUA K칍DU S OBLAKOM A TLA캛IDLOM ---
            
            const fullCodeBlock = luaCodeMatch[0];
            const pureLuaCode = luaCodeMatch[1].trim();
            
            // 1. Z칤skanie in코truk캜n칠ho textu (text mimo k칩dov칠ho bloku)
            const instructionText = text.replace(fullCodeBlock, '').trim();
            
            // 2. Form치tovanie in코trukci칤 ako markdown
            let instructionsHtml = '';
            if (typeof marked !== 'undefined') {
                instructionsHtml = marked.parse(instructionText);
            } else {
                instructionsHtml = `<p>${instructionText.replace(/\n/g, '<br>')}</p>`;
            }
            
            // Opatrn칠 escapovanie sp칛tn칳ch lomiek a dol치rov pre pou쬴tie v `onclick` atrib칰te
            const escapedCode = pureLuaCode.replace(/`/g, '\\`').replace(/\$/g, '&#36;');

            // 3. Vytvorenie HTML pre vlastn칳 Lua obal
            const luaWrapperHtml = `
                <div class="lua-code-wrapper">
                    <div class="lua-code-header">
                        <span>Lua Code (Roblox Command Bar)</span>
                        <button class="copy-button" onclick="copyToClipboard(this, \`${escapedCode}\`)">
                            Kop칤rova콘 k칩d
                        </button>
                    </div>
                    <pre class="lua-code-content">${pureLuaCode}</pre>
                </div>
            `;
            
            formattedText = instructionsHtml + luaWrapperHtml;

        } else if (typeof marked !== 'undefined') {
            // --- 맚andardn칠 Markdown pre be쬹칳 chat ---
            formattedText = marked.parse(text); 
        } else {
            formattedText = `<p>${text.replace(/\n/g, '<br>')}</p>`; 
        }
        
        bubble.innerHTML = formattedText;

        if (sender === 'ai' && sources.length > 0) {
            const sourcesList = document.createElement('div');
            sourcesList.className = "mt-2 pt-2 border-t border-gray-300 text-xs";
            sourcesList.innerHTML = `<strong class="text-gray-600">Zdroje:</strong>`;
            
            sources.slice(0, 3).forEach((source, index) => {
                if (source.uri && source.title) {
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.target = "_blank";
                    link.className = "source-link hover:text-blue-600";
                    link.textContent = `${index + 1}. ${source.title}`;
                    sourcesList.appendChild(link);
                }
            });
            bubble.appendChild(sourcesList);
        }

        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    function setLoading(isLoading, isModel = false) {
        sendChatButton.disabled = isLoading;
        send3DModelButton.disabled = isLoading; 
        input.disabled = isLoading;
        loadingIndicator.classList.toggle('hidden', !isLoading);
        
        loadingIndicator.querySelector('div').textContent = isLoading 
            ? (isModel ? 'Vytv치ram 3D model, 캜akajte...' : 'Rozm칳코쬬m...') 
            : '';
    }

    // --- Core API Logic (generovanie 3D modelu) ---

    /** Generuje k칩d pre Roblox Command Bar na vytvorenie 3D modelu. */
    async function generate3DModelCode(userPrompt) {
        
        if (!checkAndApplyRateLimit(true)) { // Aplikujeme timestamp
             return; 
        }

        displayMessage(`Po쬴adavka na 3D model: "${userPrompt}"`, 'user');
        input.value = '';
        setLoading(true, true); 

        const payload = {
            contents: [{ role: "user", parts: [{ text: userPrompt }] }],
            systemInstruction: systemInstruction3DModel, 
            generationConfig: {
                temperature: 0.5, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(textApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch(e) { /* ignore json parse error */ }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const aiCode = result.candidates?.[0]?.content?.parts?.[0]?.text || "Model neposkytol 쬴adny k칩d.";
                
                // Form치tovanie odpovede S INTRUKCIAMI a k칩dov칳m blokom (ten bude vizu치lne spracovan칳 vo funkcii displayMessage)
                const responseText = `**Vygenerovan칳 Roblox Lua K칩d:**
Tento k칩d je pripraven칳 na skop칤rovanie a vlo쬰nie priamo do **Command Bar** v Roblox Studio.

\`\`\`lua
${aiCode}
\`\`\`

**In코trukcie:**
1. Otvorte Roblox Studio a v치코 projekt.
2. Ak nevid칤te konzolu, otvorte **View** a zapnite **Command Bar** alebo stla캜te \`F9\` a prejdite na Command Bar.
3. Skop칤rujte cel칳 k칩d vy코코ie (alebo pou쬴te tla캜idlo Kop칤rova콘).
4. Vlo쬾e k칩d do **Command Bar** a stla캜te \`Enter\`. V치코 model sa objav칤 v pracovnom priestore (\`game.Workspace\`).`;
                
                displayMessage(responseText, 'ai');
                speakText("K칩d pre 3D model bol vygenerovan칳 a vlo쬰n칳 do chatu.");
                break;
                
            } catch (error) {
                console.error("Chyba po캜as volania 3D Model API:", error);
                if (attempt === maxRetries) {
                    displayMessage(`KRITICK츼 CHYBA po ${maxRetries} pokusoch: ${error.message}`, 'ai');
                }
            }
        }
        setLoading(false);
        checkAndApplyRateLimit(false); // Aktualizuje limit displej po ukon캜en칤
    }
    
    /** Spracuje odoslanie textovej chatovej ot치zky. */
    async function sendChatQuery(userQuery) {
        
        if (!checkAndApplyRateLimit(true)) { // Aplikujeme timestamp
            return; 
        }

        displayMessage(userQuery, 'user');
        input.value = '';

        chatHistory.push({ role: "user", parts: [{ text: userQuery }] });
        setLoading(true, false); 

        const payload = {
            contents: chatHistory,
            tools: [{ "google_search": {} }],
            systemInstruction: systemInstructionChat,
            generationConfig: {
                temperature: 0.7, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(textApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch (e) {
                        errorMessage = `HTTP chyba so statusom ${response.status}.`;
                    }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const aiText = candidate.content.parts[0].text;
                    
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    displayMessage(aiText, 'ai', sources);
                    speakText(aiText); // Volanie TTS
                    
                    break; 

                } else {
                    displayMessage("AI neposkytla 쬴adnu odpove캞. (Pr치zdna odpove캞 od modelu)", 'ai');
                }
            } catch (error) {
                console.error("Chyba po캜as volania API:", error);
                
                if (attempt === maxRetries) {
                    displayMessage(`KRITICK츼 CHYBA po ${maxRetries} pokusoch: ${error.message}`, 'ai');
                }
            }
        }
        setLoading(false);
        checkAndApplyRateLimit(false); // Aktualizova콘 limit displej po ukon캜en칤
    }

    // --- Event Listeners ---
    form.addEventListener('submit', function(e) {
        e.preventDefault();
        const query = input.value.trim();
        if (query) {
            sendChatQuery(query);
        }
    });

    send3DModelButton.addEventListener('click', function() {
        const query = input.value.trim();
        if (query) {
            generate3DModelCode(query);
        }
    });

    // --- Initialization ---
    window.onload = function() {
        init3D();
        animate3D();
        checkAndApplyRateLimit(false); // Inicializova콘 status limitu pri 코tarte
    };
</script>
</body>
</html>













