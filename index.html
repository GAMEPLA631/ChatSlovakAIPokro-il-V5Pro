<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatSlovak AI Pokro캜il칳 V5 PRO (s Roblox Lua 3D)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f003e; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            position: relative; 
            overflow: hidden;
        }
        #bg-canvas {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; 
            display: block;
        }
        #chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            
            /* SKLENEN칗 EFEKT */
            background-color: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(15px); 
            -webkit-backdrop-filter: blur(15px); 
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); 
            overflow: hidden;
            z-index: 10; 
        }
        
        .chat-header {
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-footer {
            background-color: rgba(255, 255, 255, 0.05); 
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .user-message {
            background-color: #3b82f6; 
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }
        .ai-message {
            background-color: rgba(255, 255, 255, 0.85); 
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.25rem;
            white-space: pre-wrap;
        }
        .source-link {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
        }
        #loading-indicator {
            padding: 0.5rem;
            text-align: center;
            color: #9ca3af;
        }
        .ai-message p, .ai-message ul, .ai-message ol, .ai-message strong {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        
        /* P칪vodn칳 코t칳l pre k칩dov칠 bloky v spr치vach - ponech치vame pre be쬹칳 textov칳 chat */
        .ai-message pre {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-top: 0.75rem;
        }

        /* --- NOV칄 T칗LY PRE LUA K칍D (POD컇A VZORU) --- */
        .lua-code-wrapper {
            background-color: #1f2937; /* Tmav칠 pozadie k칩du */
            border-radius: 0.5rem;
            margin-top: 0.75rem;
            overflow: hidden;
            position: relative;
            border: 1px solid #374151; /* Jemn칳 okraj */
        }

        .lua-code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #374151; /* Hlavi캜ka k칩du */
            color: #9ca3af; /* Siv칳 text */
            font-size: 0.875rem;
        }

        .lua-code-content {
            padding: 1rem;
            color: #d1d5db; /* Svetl칳 text k칩du */
            white-space: pre; 
            overflow-x: auto;
            font-family: monospace;
            line-height: 1.4;
            font-size: 0.9rem;
            margin: 0; /* Odstr치ni okraje <pre> elementu */
        }

        .copy-button {
            background-color: #4f46e5; /* Fialovo-modr칠 tla캜idlo */
            color: white;
            padding: 0.3rem 0.75rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.15s;
            font-weight: 500;
        }
        .copy-button:hover {
            background-color: #6366f1;
        }
        /* --- KONIEC NOV칗CH T칗LOV --- */

        /* Respons칤vny layout tla캜idiel */
        .button-group {
            display: flex;
            gap: 0.75rem;
        }
        @media (max-width: 640px) {
            .button-group {
                flex-direction: column; 
            }
            .button-group button {
                width: 100%;
            }
        }
    </style>
</head>
<body>

<!-- 3D Canvas pre dynamick칠 pozadie -->
<canvas id="bg-canvas"></canvas>

<div id="chat-container">
    <!-- Chat Header -->
    <header class="chat-header p-4 text-white text-center rounded-t-xl shadow-lg">
        <h1 class="text-xl font-bold">游눫 ChatSlovak AI Pokro캜il칳 V5 PRO (Roblox Lua 3D)</h1>
        <p class="text-sm text-gray-400">**Nov치 funkcia:** Zadajte popis pre generovanie komplexn칠ho Lua k칩du 3D modelu (Roblox Command Bar).</p>
        <!-- INDIK츼TOR STAVU LIMITU -->
        <span id="limit-status" class="text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-indigo-700/50">
            Na캜칤tavam limit...
        </span>
    </header>

    <!-- Messages Area -->
    <div id="messages">
        <!-- 칔vodn치 spr치va s upraven칳m form치tovan칤m -->
        <div class="message-bubble ai-message">
            <p>Vitaj! Model bol aktualizovan칳 pre **Generovanie 3D modelov v Lua**. Zadajte presn칳 popis modelu (napr. *detailn칳 st칤ha캜ka v retro 코t칳le*, alebo *modr치 코pir치lov치 ve쬬 so zlat칳mi prvkami*), a kliknite na **Generova콘 3D Model**.</p>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="hidden">
        <div class="animate-pulse"></div>
    </div>

    <!-- Input Form s dvoma tla캜idlami -->
    <form id="chat-form" class="p-4 chat-footer">
        <div class="flex space-x-3">
            <input type="text" id="user-input" placeholder="Zadajte popis modelu (napr. Vesm칤rna lo캞 s 3 tryskami) alebo ot치zku..." required class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            
            <div class="button-group">
                <!-- Tla캜idlo pre generovanie 3D modelu -->
                <button type="button" id="send-3d-model-button" class="bg-purple-600 text-white p-3 rounded-lg hover:bg-purple-700 transition duration-150 flex items-center justify-center disabled:bg-purple-400 min-w-max">
                    Generova콘 3D Model
                </button>
                
                <!-- Tla캜idlo pre chat -->
                <button type="submit" id="send-chat-button" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-150 flex items-center justify-center disabled:bg-blue-400 min-w-max">
                    Odosla콘
                </button>
            </div>
        </div>
    </form>
</div>

<!-- Kni쬹ice pre pokro캜il칰 funk캜nos콘 a 3D grafiku -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 3D Background Initialization (Three.js) ---
    let scene, camera, renderer, discoBall;
    let discoLights = [];
    const lightColors = [0xff00ff, 0x00ffff, 0xffff00]; 
    const canvas = document.getElementById('bg-canvas');
    let mouseX = 0, mouseY = 0;

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000); 
        camera.position.z = 200;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); 
        renderer.setSize(window.innerWidth, window.innerHeight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        scene.add(ambientLight);

        const ballGeometry = new THREE.SphereGeometry(40, 64, 32);
        const ballMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            specular: 0xffffff, 
            shininess: 100, 
            reflectivity: 0.9,
        });
        discoBall = new THREE.Mesh(ballGeometry, ballMaterial);
        scene.add(discoBall);

        const lightIntensity = 2;
        const lightDistance = 200;
        
        // Vytvorenie a umiestnenie dynamick칳ch svetiel (PointLights)
        const lightOrbitRadius = 150;
        lightColors.forEach((colorHex, index) => {
            const pointLight = new THREE.PointLight(colorHex, lightIntensity, lightDistance);
            // Po캜iato캜n칠 umiestnenie v kruhu
            pointLight.position.x = lightOrbitRadius * Math.cos(index * Math.PI * 2 / 3);
            pointLight.position.y = lightOrbitRadius * Math.sin(index * Math.PI * 2 / 3);
            pointLight.position.z = 0;
            scene.add(pointLight);
            discoLights.push(pointLight);
        });
        
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onDocumentMouseMove(event) {
        // Nastavuje poz칤ciu my코i normalizovan칰 k stredu obrazovky
        mouseX = (event.clientX - window.innerWidth / 2) * 0.2;
        mouseY = (event.clientY - window.innerHeight / 2) * 0.2;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate3D() {
        requestAnimationFrame(animate3D);

        const time = Date.now() * 0.0002;
        
        // Rot치cia diskogu쬰
        discoBall.rotation.y += 0.005; 
        discoBall.rotation.x += 0.002;

        const orbitRadius = 150;
        // Anim치cia svetiel
        discoLights.forEach((light, index) => {
            const angle = time * (index + 1) * 0.5;
            light.position.x = orbitRadius * Math.cos(angle + index * 1.5);
            light.position.z = orbitRadius * Math.sin(angle + index * 1.5);
            light.position.y = 50 * Math.sin(time + index); // Pohyb hore/dole
        });

        // Pohyb kamery pod쬬 my코i pre jemn칳 paralax efekt
        camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.y += (-mouseY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        renderer.render(scene, camera);
    }

    // --- Rate Limiting Configuration ---
    const MAX_MESSAGES_PER_HOUR = 30; 
    const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; 
    const STORAGE_KEY = 'chatSlovakMessageTimestamps';
    
    // Glob치lna premenn치 pre 캜asova캜 resetu
    window.rateLimitTimeout = null; 

    /** * Aktualizuje UI element s inform치ciou o zost치vaj칰com limite a vracia objekt so stavom.
     * @returns {object} { remaining: number, timeUntilReset: number }
     */
    function updateLimitStatusDisplay(currentTimestamps) {
        const now = Date.now();
        // Odfiltruje len tie timestampy, ktor칠 s칰 e코te v r치mci hodinov칠ho okna.
        const recentTimestamps = currentTimestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        const messagesSent = recentTimestamps.length;
        const messagesRemaining = MAX_MESSAGES_PER_HOUR - messagesSent;

        const limitStatusElement = document.getElementById('limit-status');
        
        let timeUntilResetMs = 0;

        if (messagesRemaining <= 0) {
            // Limit VY캛ERPAN칗. Vypo캜칤tame 캜as, kedy vypr코칤 najstar코ia spr치va.
            if (recentTimestamps.length > 0) {
                // Najprv zorad칤me, aby sme na코li najstar코iu spr치vu
                const oldestTimestamp = recentTimestamps.sort((a, b) => a - b)[0];
                timeUntilResetMs = RATE_LIMIT_WINDOW_MS - (now - oldestTimestamp);
                if (timeUntilResetMs < 0) timeUntilResetMs = 0; // Ak 캜as u uplynul, nastav칤me na 0.
            }
            
            const minutes = Math.floor(timeUntilResetMs / 60000);
            const seconds = Math.floor((timeUntilResetMs % 60000) / 1000);
            
            // UI Update
            limitStatusElement.textContent = `Limit VY캛ERPAN칗. Reset za ${minutes}m ${seconds}s`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-red-700/70";
            
            return { remaining: 0, timeUntilReset: timeUntilResetMs };

        } else {
            // Limit OK
            limitStatusElement.textContent = `Zost치va: ${messagesRemaining} z ${MAX_MESSAGES_PER_HOUR} spr치v/h`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-green-600/70";
            
            return { remaining: messagesRemaining, timeUntilReset: 0 };
        }
    }

    /**
     * Kontroluje a aplikuje limit po캜tu spr치v pomocou localStorage.
     * Taktie nastavuje automatick칳 캜asova캜 resetu, ak je limit prekro캜en칳.
     * @param {boolean} apply - Ak je true, aplikuje sa nov칳 timestamp (odosiela sa spr치va).
     * @returns {boolean} True, ak je povolen칠 odosla콘 spr치vu.
     */
    function checkAndApplyRateLimit(apply = false) { 
        const now = Date.now();
        let timestamps = [];
        
        // 1. Na캜칤ta콘 a vy캜isti콘 star칠 캜asy
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                timestamps = JSON.parse(stored);
                if (!Array.isArray(timestamps)) {
                    timestamps = [];
                }
            }
        } catch (e) {
            console.error("Chyba pri 캜칤tan칤 localStorage:", e);
            timestamps = [];
        }

        let recentTimestamps = timestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        
        // 2. Skontrolova콘 limit
        const { remaining: messagesRemaining, timeUntilReset } = updateLimitStatusDisplay(recentTimestamps);

        // 3. Logika aplik치cie a monitorovania
        if (messagesRemaining > 0) {
            // Limit OK. Zru코칤me existuj칰ci 캜asova캜 (ak nejak칳 be쬬l z predch치dzaj칰ceho zlyhania)
            if (window.rateLimitTimeout) {
                clearTimeout(window.rateLimitTimeout);
                window.rateLimitTimeout = null;
            }

            if (apply) {
                // Ak sa m치 aplikova콘 (odosiela sa spr치va), prid치me nov칳 timestamp
                recentTimestamps.push(now);
                
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(recentTimestamps));
                } catch (e) {
                    console.error("Chyba pri z치pise do localStorage:", e);
                }
                // Prekresl칤me UI po pridan칤 novej spr치vy
                updateLimitStatusDisplay(recentTimestamps); 
            }
            
            return true; 
        } else {
            // Limit VY캛ERPAN칗. Nastav칤me 캜asova캜 na kontrolu, ak e코te nie je spusten칳.
            if (timeUntilReset > 0) {
                if (window.rateLimitTimeout) {
                    clearTimeout(window.rateLimitTimeout); // V쬯y vy캜ist칤me star칳, aby sme predi코li duplik치tom
                }
                
                // Nastav칤me timeout o 1 sekundu dlh코칤 ako je 캜as do resetu pre zaru캜enie uplynutia.
                window.rateLimitTimeout = setTimeout(() => {
                    window.rateLimitTimeout = null; 
                    checkAndApplyRateLimit(false); // Skontrolujeme znova bez aplik치cie timestampu
                }, timeUntilReset + 1000); 
            }
            
            return false;
        }
    }

    // --- Text-to-Speech (TTS) Functionality ---
    const synth = window.speechSynthesis;
    let voices = [];

    function populateVoiceList() {
        voices = synth.getVoices();
    }

    if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = populateVoiceList;
    } else {
        populateVoiceList(); 
    }
    
    function speakText(text) {
        if (!synth || !text) return;
        
        if (synth.speaking) {
            synth.cancel();
        }

        const cleanText = text.replace(/\*\*/g, '').replace(/###\s*/g, ''); 
        const utterance = new SpeechSynthesisUtterance(cleanText);

        let selectedVoice = voices.find(voice => voice.lang.startsWith('sk-SK'));
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.name.includes('Google') && voice.lang.startsWith('en'));
        }
        if (!selectedVoice) {
            selectedVoice = voices[0];
        }

        if (selectedVoice) {
            utterance.voice = selectedVoice;
            utterance.lang = selectedVoice.lang;
        } else {
            utterance.lang = 'sk-SK'; 
        }

        utterance.rate = 1.0; 
        utterance.pitch = 1.0; 

        synth.speak(utterance);
    }


    // --- API Configuration and Global Variables ---

    const apiKey = "AIzaSyAzWkdCBiqlrFZODs2zEichlIWe68Wo2eI"; 
    const apiUrlBase = "https://generativelanguage.googleapis.com/v1beta/models/";
    
    // Konfigur치cia pre text a 3D modely (Gemini 2.5 Pro)
    const textModelName = 'gemini-2.5-pro'; 
    const textApiUrl = `${apiUrlBase}${textModelName}:generateContent?key=${apiKey}`;

    // V코eobecn치 syst칠mov치 in코trukcia pre chat
    const systemInstructionChat = {
        parts: [{ 
            // UPDATOVAN츼 INTRUKCIA: Odstr치nenie po쬴adavky na nadpisy (##) a zv칳raznenie tu캜n칠ho textu a zoznamov ako prim치rneho n치stroja pre 코trukt칰ru.
            text: "Si 코pi캜kov칳 analytik, strat칠g a vedeck칳 konzultant. Tvojou 칰lohou je spracov치va콘 mimoriadne zlo쬴t칠, multi-disciplin치rne ot치zky. Tvoje odpovede musia by콘 h컄bkov칠, syntetick칠 a MUSIA BY콗 V콯DY logicky a vizu치lne 코trukt칰rovan칠. Pou쮂셨aj Markdown pre: **1. Odr치쬶y/Zoznamy pre preh쬬dn칠 body.** **2. Tu캜n칳 text (**slovo**) pre k쮂줷꼂v칠 pojmy a odde쬺vanie sekci칤.** D칎LE콯IT칄: NIKDY nepou쮂셨aj symbol `#` (nadpisy). 3. V쬯y pou쬴 Google Search na overenie a poskytnutie aktu치lnych, faktick칳ch inform치ci칤 pre komplexn칠 t칠my. Odpovedaj v칳hradne v sloven캜ine a bu캞 u쬴to캜n칳."
        }]
    };
    
    // Syst칠mov치 in코trukcia pre generovanie 3D Lua k칩du
    const systemInstruction3DModel = {
        parts: [{
            text: `You are an expert Roblox Lua script writer. Your task is to generate clean, self-contained Lua code for the Roblox Studio Command Bar to construct an advanced 3D model based on the user's description. The code MUST:
1.  Be runnable instantly in the Command Bar.
2.  Use basic Roblox Parts, CFrame, and Materials.
3.  Be contained in a single code block.
4.  Start with 'local model = Instance.new("Model", game.Workspace)' and ensure all created parts are parented to this model for easy deletion.
5.  Use comments sparingly, only for complex logic.
6.  The final output MUST ONLY contain the Lua code (no introductory text, explanations, or markdown fences outside the code block).`
        }]
    };


    let chatHistory = [];
    const messagesDiv = document.getElementById('messages');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('user-input');
    const sendChatButton = document.getElementById('send-chat-button');
    const send3DModelButton = document.getElementById('send-3d-model-button'); 
    const loadingIndicator = document.getElementById('loading-indicator');


    // --- Utility Functions ---

    function delay(attempt) {
        const baseDelay = 1000;
        const maxDelay = 16000;
        const currentDelay = Math.min(maxDelay, baseDelay * Math.pow(2, attempt - 1));
        return new Promise(resolve => setTimeout(resolve, currentDelay));
    }

    /**
     * NOV츼 FUNKCIA: Skop칤ruje text do schr치nky a zmen칤 text tla캜idla.
     */
    function copyToClipboard(button, textToCopy) {
        // Pou쬴tie document.execCommand('copy') pre kompatibilitu v iFrame
        const textarea = document.createElement('textarea');
        textarea.value = textToCopy;
        textarea.style.position = 'fixed'; 
        textarea.style.opacity = 0;
        document.body.appendChild(textarea);
        textarea.select();
        
        try {
            const success = document.execCommand('copy');
            if (success) {
                const originalText = button.textContent;
                button.textContent = 'Skop칤rovan칠!';
                button.style.backgroundColor = '#10b981'; // Green color for success
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#4f46e5'; // Restore color
                }, 2000);
            } else {
                console.error('Kop칤rovanie zlyhalo.');
            }
        } catch (err) {
            console.error('Kop칤rovanie ne칰spe코n칠', err);
        }
        document.body.removeChild(textarea);
    }
    
    // Spr칤stupn칤 funkciu glob치lne, aby ju bolo mo쬹칠 vola콘 z dynamicky vygenerovan칠ho HTML
    window.copyToClipboard = copyToClipboard; 


    // --- UI Functions ---

    function displayMessage(text, sender, sources = []) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender === 'user' ? 'user-message' : 'ai-message'}`;
        
        let formattedText = '';
        const luaCodeMatch = text.match(/```lua\s*([\s\S]*?)```/); // Regex pre n치jdenie Lua k칩du

        if (sender === 'ai' && luaCodeMatch) {
            // --- VLASTN칄 RENDEROVANIE LUA K칍DU S OBLAKOM A TLA캛IDLOM ---
            
            const fullCodeBlock = luaCodeMatch[0];
            const pureLuaCode = luaCodeMatch[1].trim();
            
            // 1. Z칤skanie in코truk캜n칠ho textu (text mimo k칩dov칠ho bloku)
            const instructionText = text.replace(fullCodeBlock, '').trim();
            
            // 2. Form치tovanie in코trukci칤 ako markdown
            let instructionsHtml = '';
            if (typeof marked !== 'undefined') {
                instructionsHtml = marked.parse(instructionText);
            } else {
                instructionsHtml = `<p>${instructionText.replace(/\n/g, '<br>')}</p>`;
            }
            
            // Opatrn칠 escapovanie sp칛tn칳ch lomiek a dol치rov pre pou쬴tie v `onclick` atrib칰te
            const escapedCode = pureLuaCode.replace(/`/g, '\\`').replace(/$/g, '&#36;');

            // 3. Vytvorenie HTML pre vlastn칳 Lua obal
            const luaWrapperHtml = `
                <div class="lua-code-wrapper">
                    <div class="lua-code-header">
                        <span>Lua Code (Roblox Command Bar)</span>
                        <button class="copy-button" onclick="copyToClipboard(this, \`${escapedCode}\`)">
                            Kop칤rova콘 k칩d
                        </button>
                    </div>
                    <pre class="lua-code-content">${pureLuaCode}</pre>
                </div>
            `;
            
            formattedText = instructionsHtml + luaWrapperHtml;

        } else if (typeof marked !== 'undefined') {
            // --- 맚andardn칠 Markdown pre be쬹칳 chat ---
            formattedText = marked.parse(text); 
        } else {
            formattedText = `<p>${text.replace(/\n/g, '<br>')}</p>`; 
        }
        
        bubble.innerHTML = formattedText;

        if (sender === 'ai' && sources.length > 0) {
            const sourcesList = document.createElement('div');
            sourcesList.className = "mt-2 pt-2 border-t border-gray-300 text-xs";
            sourcesList.innerHTML = `<strong class="text-gray-600">Zdroje:</strong>`;
            
            sources.slice(0, 3).forEach((source, index) => {
                if (source.uri && source.title) {
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.target = "_blank";
                    link.className = "source-link hover:text-blue-600";
                    link.textContent = `${index + 1}. ${source.title}`;
                    sourcesList.appendChild(link);
                }
            });
            bubble.appendChild(sourcesList);
        }

        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    function setLoading(isLoading, isModel = false) {
        sendChatButton.disabled = isLoading;
        send3DModelButton.disabled = isLoading; 
        input.disabled = isLoading;
        loadingIndicator.classList.toggle('hidden', !isLoading);
        
        loadingIndicator.querySelector('div').textContent = isLoading 
            ? (isModel ? 'Vytv치ram 3D model, 캜akajte...' : 'Rozm칳코쬬m...') 
            : '';
    }

    // --- Core API Logic (generovanie 3D modelu) ---

    /** Generuje k칩d pre Roblox Command Bar na vytvorenie 3D modelu. */
    async function generate3DModelCode(userPrompt) {
        
        if (!checkAndApplyRateLimit(true)) { // Aplikujeme timestamp
             return; 
        }

        displayMessage(`Po쬴adavka na 3D model: "${userPrompt}"`, 'user');
        input.value = '';
        setLoading(true, true); 

        const payload = {
            contents: [{ role: "user", parts: [{ text: userPrompt }] }],
            systemInstruction: systemInstruction3DModel, 
            generationConfig: {
                temperature: 0.5, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(textApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch(e) { /* ignore json parse error */ }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const aiCode = result.candidates?.[0]?.content?.parts?.[0]?.text || "Model neposkytol 쬴adny k칩d.";
                
                // Form치tovanie odpovede S INTRUKCIAMI a k칩dov칳m blokom (ten bude vizu치lne spracovan칳 vo funkcii displayMessage)
                const responseText = `**Vygenerovan칳 Roblox Lua K칩d:**
Tento k칩d je pripraven칳 na skop칤rovanie a vlo쬰nie priamo do **Command Bar** v Roblox Studio.

\`\`\`lua
${aiCode}
\`\`\`

**In코trukcie:**
1. Otvorte Roblox Studio a v치코 projekt.
2. Ak nevid칤te konzolu, otvorte **View** a zapnite **Command Bar** alebo stla캜te \`F9\` a prejdite na Command Bar.
3. Skop칤rujte cel칳 k칩d vy코코ie (alebo pou쬴te tla캜idlo Kop칤rova콘).
4. Vlo쬾e k칩d do **Command Bar** a stla캜te \`Enter\`. V치코 model sa objav칤 v pracovnom priestore (\`game.Workspace\`).`;
                
                displayMessage(responseText, 'ai');
                speakText("K칩d pre 3D model bol vygenerovan칳 a vlo쬰n칳 do chatu.");
                break;
                
            } catch (error) {
                console.error("Chyba po캜as volania 3D Model API:", error);
                if (attempt === maxRetries) {
                    displayMessage(`KRITICK츼 CHYBA po ${maxRetries} pokusoch: ${error.message}`, 'ai');
                }
            }
        }
        setLoading(false);
    }
    
    /** Spracuje odoslanie textovej chatovej ot치zky. */
    async function sendChatQuery(userQuery) {
        
        if (!checkAndApplyRateLimit(true)) { // Aplikujeme timestamp
            return; 
        }

        displayMessage(userQuery, 'user');
        input.value = '';

        chatHistory.push({ role: "user", parts: [{ text: userQuery }] });
        setLoading(true, false); 

        const payload = {
            contents: chatHistory,
            tools: [{ "google_search": {} }],
            systemInstruction: systemInstructionChat,
            generationConfig: {
                temperature: 0.7, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(textApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch (e) {
                        errorMessage = `HTTP chyba so statusom ${response.status}.`;
                    }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const aiText = candidate.content.parts[0].text;
                    
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    displayMessage(aiText, 'ai', sources);
                    speakText(aiText); // Volanie TTS
                    
                    break; 

                } else {
                    displayMessage("AI neposkytla 쬴adnu odpove캞. (Pr치zdna odpove캞 od modelu)", 'ai');
                }
            } catch (error) {
                console.error("Chyba po캜as volania API:", error);
                
                if (attempt === maxRetries) {
                    const errorMessage = `Nastala kritick치 chyba pri komunik치cii s AI po ${maxRetries} pokusoch. (${error.message})`;
                    displayMessage(errorMessage, 'ai');
                }
            }
        }

        setLoading(false);
    }
    
    // --- Spustenie aplik치cie a event listenery ---

    window.onload = function () {
        init3D();
        animate3D();
        
        // Pri 코tarte len skontrolujeme limit bez aplik치cie (apply=false)
        checkAndApplyRateLimit(false); 
        
        // Listener pre tla캜idlo CHAT (Odosla콘)
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const userQuery = input.value.trim();
            if (!userQuery) return;
            
            if (!apiKey) {
                displayMessage("CHYBA: API k쮂줷 nie je nastaven칳. (Nedostato캜n치 autoriz치cia)", 'ai');
                return;
            }
            sendChatQuery(userQuery);
        });

        // Listener pre tla캜idlo 3D MODEL (Generova콘 3D Model)
        send3DModelButton.addEventListener('click', async () => {
            const userPrompt = input.value.trim();
            
            if (!userPrompt) {
                displayMessage("Pros칤m, zadajte podrobn칳 popis 3D modelu, ktor칳 m치 AI vygenerova콘 v Lua k칩de.", 'ai');
                return;
            }

            if (!apiKey) {
                displayMessage("CHYBA: API k쮂줷 nie je nastaven칳. (Nedostato캜n치 autoriz치cia)", 'ai');
                return;
            }
            
            await generate3DModelCode(userPrompt);
        });


        // Pre캜칤tanie 칰vodnej spr치vy po na캜칤tan칤 hlasov
        const initialMessageText = "Vitaj! Model bol aktualizovan칳 pre Generovanie 3D modelov v Lua. Zadajte presn칳 popis modelu a kliknite na Generova콘 3D Model.";
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = () => {
                populateVoiceList();
                if (messagesDiv.children.length === 1) { 
                     speakText(initialMessageText);
                }
            };
        } else {
            setTimeout(() => {
                if (messagesDiv.children.length === 1) { 
                     speakText(initialMessageText);
                }
            }, 500);
        }
    }

</script>
</body>
</html>












