<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatSlovak AI Pokro캜il칳 V5 Pro (s Obr치zkami)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f003e; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            position: relative; 
            overflow: hidden;
        }
        #bg-canvas {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; 
            display: block;
        }
        #chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            
            /* SKLENEN칗 EFEKT */
            background-color: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(15px); 
            -webkit-backdrop-filter: blur(15px); 
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); 
            overflow: hidden;
            z-index: 10; 
        }
        
        .chat-header {
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-footer {
            background-color: rgba(255, 255, 255, 0.05); 
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .user-message {
            background-color: #3b82f6; 
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }
        .ai-message {
            background-color: rgba(255, 255, 255, 0.85); 
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.25rem;
            white-space: pre-wrap;
        }
        .source-link {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
        }
        #loading-indicator {
            padding: 0.5rem;
            text-align: center;
            color: #9ca3af;
        }
        .ai-message p, .ai-message ul, .ai-message ol, .ai-message strong {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        .image-container {
            margin-top: 1rem;
            text-align: center;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            overflow: hidden;
            background-color: #fff;
        }
        .generated-image {
            max-width: 100%;
            height: auto;
            display: block;
            /* Zabezpe캜칤, 쬰 16:9 obr치zok sa v kontajneri zobraz칤 spr치vne bez skreslenia */
            aspect-ratio: 16 / 9; 
            object-fit: contain; 
        }
        /* Respons칤vny layout tla캜idiel */
        .button-group {
            display: flex;
            gap: 0.75rem;
        }
        @media (max-width: 640px) {
            .button-group {
                flex-direction: column; 
            }
            .button-group button {
                width: 100%;
            }
        }
    </style>
</head>
<body>

<!-- 3D Canvas pre dynamick칠 pozadie -->
<canvas id="bg-canvas"></canvas>

<div id="chat-container">
    <!-- Chat Header -->
    <header class="chat-header p-4 text-white text-center rounded-t-xl shadow-lg">
        <h1 class="text-xl font-bold">游눫 ChatSlovak AI Pokro캜il칳 V5 PRO</h1>
        <p class="text-sm text-gray-400">Pre textov칰 odpove캞 pou쬴te **Odosla콘**. Pre obr치zok (16:9) pou쬴te **Generova콘 Obr치zok**.</p>
        <!-- INDIK츼TOR STAVU LIMITU (Kontrola je lok치lna cez localStorage, NIE cez datab치zu Firebase) -->
        <span id="limit-status" class="text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-indigo-700/50">
            Na캜칤tavam limit...
        </span>
    </header>

    <!-- Messages Area -->
    <div id="messages">
        <!-- 칔vodn치 spr치va s upraven칳m form치tovan칤m -->
        <div class="message-bubble ai-message">
            <p>Vitaj! Model bol teraz aktualizovan칳. Ak chcete vytvori콘 obr치zok vo form치te **16:9** s textom, zadajte popis do po쬬 a kliknite na tla캜idlo **Generova콘 Obr치zok**.</p>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loading-indicator" class="hidden">
        <div class="animate-pulse">Rozm칳코쬬m...</div>
    </div>

    <!-- Input Form s dvoma tla캜idlami -->
    <form id="chat-form" class="p-4 border-t border-gray-200 chat-footer">
        <div class="flex space-x-3">
            <input type="text" id="user-input" placeholder="Zadajte text pre chat alebo popis pre obr치zok..." required class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            
            <div class="button-group">
                <!-- Nov칠 tla캜idlo pre generovanie obr치zka (typ="button" aby sa nesp칰코콘al submit) -->
                <button type="button" id="send-image-button" class="bg-indigo-600 text-white p-3 rounded-lg hover:bg-indigo-700 transition duration-150 flex items-center justify-center disabled:bg-indigo-400 min-w-max">
                    Generova콘 Obr치zok
                </button>
                
                <!-- P칪vodn칠 tla캜idlo pre chat (typ="submit") -->
                <button type="submit" id="send-chat-button" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition duration-150 flex items-center justify-center disabled:bg-blue-400 min-w-max">
                    Odosla콘
                </button>
            </div>
        </div>
    </form>
</div>

<!-- Kni쬹ice pre pokro캜il칰 funk캜nos콘 a 3D grafiku -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 3D Background Initialization (Three.js) ---
    let scene, camera, renderer, discoBall;
    let discoLights = [];
    const lightColors = [0xff00ff, 0x00ffff, 0xffff00]; 
    const canvas = document.getElementById('bg-canvas');
    let mouseX = 0, mouseY = 0;

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000); 
        camera.position.z = 200;

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); 
        renderer.setSize(window.innerWidth, window.innerHeight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        scene.add(ambientLight);

        const ballGeometry = new THREE.SphereGeometry(40, 64, 32);
        const ballMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            specular: 0xffffff, 
            shininess: 100, 
            reflectivity: 0.9,
        });
        discoBall = new THREE.Mesh(ballGeometry, ballMaterial);
        scene.add(discoBall);

        const lightIntensity = 2;
        const lightDistance = 200;
        
        // Vytvorenie a umiestnenie dynamick칳ch svetiel (PointLights)
        const lightOrbitRadius = 150;
        lightColors.forEach((colorHex, index) => {
            const pointLight = new THREE.PointLight(colorHex, lightIntensity, lightDistance);
            // Po캜iato캜n칠 umiestnenie v kruhu
            pointLight.position.x = lightOrbitRadius * Math.cos(index * Math.PI * 2 / 3);
            pointLight.position.y = lightOrbitRadius * Math.sin(index * Math.PI * 2 / 3);
            pointLight.position.z = 0;
            scene.add(pointLight);
            discoLights.push(pointLight);
        });
        
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onDocumentMouseMove(event) {
        // Nastavuje poz칤ciu my코i normalizovan칰 k stredu obrazovky
        mouseX = (event.clientX - window.innerWidth / 2) * 0.2;
        mouseY = (event.clientY - window.innerHeight / 2) * 0.2;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate3D() {
        requestAnimationFrame(animate3D);

        const time = Date.now() * 0.0002;
        
        // Rot치cia diskogu쬰
        discoBall.rotation.y += 0.005; 
        discoBall.rotation.x += 0.002;

        const orbitRadius = 150;
        // Anim치cia svetiel
        discoLights.forEach((light, index) => {
            const angle = time * (index + 1) * 0.5;
            light.position.x = orbitRadius * Math.cos(angle + index * 1.5);
            light.position.z = orbitRadius * Math.sin(angle + index * 1.5);
            light.position.y = 50 * Math.sin(time + index); // Pohyb hore/dole
        });

        // Pohyb kamery pod쬬 my코i pre jemn칳 paralax efekt
        camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.y += (-mouseY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        renderer.render(scene, camera);
    }

    // --- Rate Limiting Configuration ---
    // T치to 캜as콘 pou쮂셨a LOK츼LNE 칰lo쬴sko (localStorage), NIE datab치zu Firebase.
    const MAX_MESSAGES_PER_HOUR = 30; 
    const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; 
    const STORAGE_KEY = 'chatSlovakMessageTimestamps';

    /** * Aktualizuje UI element s inform치ciou o zost치vaj칰com limite a vracia zost치vaj칰ce spr치vy. */
    function updateLimitStatusDisplay(currentTimestamps) {
        const now = Date.now();
        
        // Filtruje 캜asov칠 pe캜iatky len v r치mci poslednej hodiny
        const recentTimestamps = currentTimestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);
        
        const messagesSent = recentTimestamps.length;
        const messagesRemaining = MAX_MESSAGES_PER_HOUR - messagesSent;

        const limitStatusElement = document.getElementById('limit-status');
        
        if (messagesRemaining <= 0) {
            // Zist칤me 캜as do resetu na z치klade najstar코ej spr치vy v poslednej hodine
            const timeUntilResetMs = recentTimestamps.length > 0 
                ? RATE_LIMIT_WINDOW_MS - (now - recentTimestamps.sort((a, b) => a - b)[0]) // Sort pre najstar코iu
                : 0; 
            
            const minutes = Math.floor(timeUntilResetMs / 60000);
            const seconds = Math.floor((timeUntilResetMs % 60000) / 1000);
            
            limitStatusElement.textContent = `Limit VY캛ERPAN칗. Reset za ${minutes}m ${seconds}s`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-red-700/70";
            return 0;
        } else {
            limitStatusElement.textContent = `Zost치va: ${messagesRemaining} z ${MAX_MESSAGES_PER_HOUR} spr치v/h`;
            limitStatusElement.className = "text-xs font-medium mt-1 inline-block py-1 px-3 rounded-full bg-green-600/70";
            return messagesRemaining;
        }
    }


    /**
     * Kontroluje a aplikuje limit po캜tu spr치v pomocou localStorage.
     * @returns {boolean} True, ak je povolen칠 odosla콘 spr치vu.
     */
    function checkAndApplyRateLimit() {
        const now = Date.now();
        let timestamps = [];
        
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                timestamps = JSON.parse(stored);
                if (!Array.isArray(timestamps)) {
                    timestamps = [];
                }
            }
        } catch (e) {
            console.error("Chyba pri 캜칤tan칤 localStorage:", e);
            timestamps = [];
        }

        let recentTimestamps = timestamps.filter(timestamp => (now - timestamp) < RATE_LIMIT_WINDOW_MS);

        const messagesRemaining = updateLimitStatusDisplay(recentTimestamps);

        if (messagesRemaining > 0) {
            recentTimestamps.push(now);
            
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(recentTimestamps));
            } catch (e) {
                console.error("Chyba pri z치pise do localStorage:", e);
            }
            
            updateLimitStatusDisplay(recentTimestamps); 
            return true; 
        } else {
            return false;
        }
    }

    // --- Text-to-Speech (TTS) Functionality ---
    const synth = window.speechSynthesis;
    let voices = [];

    function populateVoiceList() {
        voices = synth.getVoices();
    }

    // Na캜칤tanie dostupn칳ch hlasov
    if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = populateVoiceList;
    } else {
        populateVoiceList(); 
    }
    
    function speakText(text) {
        if (!synth || !text) return;
        
        // Zastavenie predo코l칠ho hovorenia
        if (synth.speaking) {
            synth.cancel();
        }

        // Odstr치nenie zna캜iek Markdown (tu캜n칠 p칤smo) pre lep코칤 z치쬴tok z hovorenia
        const cleanText = text.replace(/\*\*/g, '').replace(/###\s*/g, ''); 

        const utterance = new SpeechSynthesisUtterance(cleanText);

        // 1. Prioritne n치jdeme slovensk칳 hlas
        let selectedVoice = voices.find(voice => voice.lang.startsWith('sk-SK'));

        // 2. Ak slovensk칳 nie je, h쬬d치me nejak칳 pekn칳 anglick칳 (캜asto Google)
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.name.includes('Google') && voice.lang.startsWith('en'));
        }
        
        // 3. Fallback na prv칳 dostupn칳 hlas
        if (!selectedVoice) {
            selectedVoice = voices[0];
        }

        // Aplik치cia vybran칠ho hlasu
        if (selectedVoice) {
            utterance.voice = selectedVoice;
            utterance.lang = selectedVoice.lang;
        } else {
             // Nastav칤me aspo켿 slovensk칳 jazyk, aby prehliada캜 vybral default SK/CZ hlas
            utterance.lang = 'sk-SK'; 
        }

        // Pr칤jemn칠 nastavenie r칳chlosti a v칳코ky
        utterance.rate = 1.0; 
        utterance.pitch = 1.0; 

        synth.speak(utterance);
    }


    // --- API Configuration and Global Variables ---

    const apiKey = "AIzaSyAzWkdCBiqlrFZODs2zEichlIWe68Wo2eI"; 
    const apiUrlBase = "https://generativelanguage.googleapis.com/v1beta/models/";
    
    // Konfigur치cia pre text (Gemini 2.5 Pro)
    const textModelName = 'gemini-2.5-pro'; 
    const textApiUrl = `${apiUrlBase}${textModelName}:generateContent?key=${apiKey}`;

    // Konfigur치cia pre obr치zky (Imagen 3.0)
    const imageModelName = 'imagen-3.0-generate-002';
    const imageApiUrl = `${apiUrlBase}${imageModelName}:predict?key=${apiKey}`;


    const systemInstruction = {
        parts: [{ 
            text: "Si 코pi캜kov칳 analytik, strat칠g a vedeck칳 konzultant. Tvojou 칰lohou je spracov치va콘 mimoriadne zlo쬴t칠, multi-disciplin치rne ot치zky. Tvoje odpovede musia by콘 h컄bkov칠, syntetick칠, logicky 코trukt칰rovan칠 (napr. s pou쬴t칤m o캜칤slovan칳ch bodov, odsekov alebo zoznamov) a musia preukazova콘 pokro캜il칠 kritick칠 myslenie. Vyhni sa zbyto캜n칠mu tu캜n칠mu p칤smu (markdown **), aby bol hlasov칳 v칳stup plynulej코칤. V쬯y pou쬴 Google Search na overenie a poskytnutie aktu치lnych, faktick칳ch inform치ci칤 pre komplexn칠 t칠my, ak si to ot치zka vy쬬duje. Odpovedaj v칳hradne v sloven캜ine." 
        }]
    };

    let chatHistory = [];
    const messagesDiv = document.getElementById('messages');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('user-input');
    const sendChatButton = document.getElementById('send-chat-button');
    const sendImageButton = document.getElementById('send-image-button');
    const loadingIndicator = document.getElementById('loading-indicator');

    // --- Utility Functions ---

    function delay(attempt) {
        const baseDelay = 1000;
        const maxDelay = 16000;
        const currentDelay = Math.min(maxDelay, baseDelay * Math.pow(2, attempt - 1));
        return new Promise(resolve => setTimeout(resolve, currentDelay));
    }

    // --- UI Functions ---

    function displayMessage(text, sender, sources = []) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender === 'user' ? 'user-message' : 'ai-message'}`;
        
        let formattedText;
        if (typeof marked !== 'undefined') {
            formattedText = marked.parse(text); 
        } else {
            formattedText = `<p>${text.replace(/\n/g, '<br>')}</p>`; 
        }
        
        bubble.innerHTML = formattedText;

        if (sender === 'ai' && sources.length > 0) {
            const sourcesList = document.createElement('div');
            sourcesList.className = "mt-2 pt-2 border-t border-gray-300 text-xs";
            sourcesList.innerHTML = `<strong class="text-gray-600">Zdroje:</strong>`;
            
            sources.slice(0, 3).forEach((source, index) => {
                if (source.uri && source.title) {
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.target = "_blank";
                    link.className = "source-link hover:text-blue-600";
                    link.textContent = `${index + 1}. ${source.title}`;
                    sourcesList.appendChild(link);
                }
            });
            bubble.appendChild(sourcesList);
        }

        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function displayImage(base64Data, prompt) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ai-message w-full max-w-lg mx-auto`;
        
        const imageContainer = document.createElement('div');
        imageContainer.className = 'image-container';

        const image = document.createElement('img');
        image.src = `data:image/png;base64,${base64Data}`;
        image.alt = `Generovan칳 obr치zok: ${prompt}`;
        image.className = 'generated-image';

        const downloadLink = document.createElement('a');
        downloadLink.href = image.src;
        // Nastavenie mena s칰boru pre stiahnutie
        downloadLink.download = `obrazok_16x9_${Date.now()}.png`; 
        downloadLink.className = 'block w-full bg-blue-600 text-white p-2 text-center hover:bg-blue-700 transition duration-150 rounded-b-lg';
        downloadLink.textContent = 'Stiahnu콘 obr치zok (vysok치 kvalita)';

        const description = document.createElement('p');
        description.className = 'text-xs text-gray-500 p-2 italic';
        description.textContent = `Generovan칳 obr치zok (16:9) na z치klade popisu: "${prompt}"`;


        imageContainer.appendChild(image);
        imageContainer.appendChild(downloadLink);
        
        bubble.appendChild(description);
        bubble.appendChild(imageContainer);


        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        speakText("Obr치zok bol 칰spe코ne vygenerovan칳 a je pripraven칳 na stiahnutie.");
    }

    function setLoading(isLoading, isImage = false) {
        sendChatButton.disabled = isLoading;
        sendImageButton.disabled = isLoading;
        input.disabled = isLoading;
        loadingIndicator.classList.toggle('hidden', !isLoading);
        
        loadingIndicator.querySelector('div').textContent = isLoading 
            ? (isImage ? 'Generujem obr치zok...' : 'Rozm칳코쬬m...')
            : '';
    }

    // --- Core API Logic ---

    /** Generuje obr치zok pomocou Imagen 3.0. */
    async function generateImageFromPrompt(userPrompt) {
        
        if (!checkAndApplyRateLimit()) {
             return; 
        }

        setLoading(true, true); 

        // Pomocn칳 prompt pre lep코iu kvalitu, ale s men코칤m d칪razom na text, aby nebol pr칤li코 re코trikt칤vny
        const imagePrompt = `Wide-screen 16:9 cinematic photo of: "${userPrompt}". High detail, photorealistic.`;

        const payload = {
            instances: { 
                prompt: imagePrompt 
            },
            parameters: { 
                "sampleCount": 1,
                "aspectRatio": "16:9" // IROKOUHL칗 FORM츼T
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(imageApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    
                    if (response.status === 400) {
                        errorMessage = `Chyba 400: V치코 popis je pravdepodobne v rozpore s bezpe캜nostn칳mi pravidlami AI (napr. explicitn칳 obsah, autorsk칠 pr치va, nevhodn치 t칠ma). Sk칰ste in칳, menej kontroverzn칳 popis.`;
                    } else if (response.status === 429) {
                        errorMessage = `Chyba 429: Prekro캜en치 kv칩ta. Sk칰ste to nesk칪r.`;
                    } else {
                         // Pokus o z칤skanie podrobnej코ej chyby
                        try {
                             const errorBody = await response.json();
                             if (errorBody && errorBody.error && errorBody.error.message) {
                                 errorMessage = `API Chyba ${response.status}: ${errorBody.error.message}`;
                             }
                        } catch(e) { /* ignore json parse error */ }
                    }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const base64Data = result.predictions?.[0]?.bytesBase64Encoded;
                
                if (base64Data) {
                    displayImage(base64Data, userPrompt);
                    break;
                } else {
                    displayMessage("AI neposkytla 쬴adnu obr치zkov칰 odpove캞. (Pr치zdna odpove캞 od Imagen API)", 'ai');
                    break; 
                }
            } catch (error) {
                console.error("Chyba po캜as volania Imagen API:", error);
                if (attempt === maxRetries) {
                    displayMessage(`KRITICK츼 CHYBA po ${maxRetries} pokusoch: ${error.message}`, 'ai');
                }
            }
        }
        setLoading(false);
    }
    
    /** Spracuje odoslanie textovej chatovej ot치zky. */
    async function sendChatQuery(userQuery) {
        
        if (!checkAndApplyRateLimit()) {
            return; 
        }

        displayMessage(userQuery, 'user');
        input.value = '';

        chatHistory.push({ role: "user", parts: [{ text: userQuery }] });
        setLoading(true, false); // false = not image

        const payload = {
            contents: chatHistory,
            tools: [{ "google_search": {} }],
            systemInstruction: systemInstruction,
            generationConfig: {
                temperature: 0.7, 
            }
        };

        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(textApiUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMessage = `HTTP chyba so statusom: ${response.status}.`;
                    try {
                        const errorBody = await response.json();
                        if (errorBody && errorBody.error && errorBody.error.message) {
                            errorMessage = `Chyba API: ${errorBody.error.message}`;
                        }
                    } catch (e) {
                        errorMessage = `HTTP chyba so statusom ${response.status}.`;
                    }

                    if (attempt < maxRetries) {
                        console.warn(`Pokus ${attempt} zlyhal, opakujem za chv칤쬿: ${errorMessage}`);
                        await delay(attempt);
                        continue;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const aiText = candidate.content.parts[0].text;
                    
                    let sources = [];
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    displayMessage(aiText, 'ai', sources);
                    speakText(aiText); // Volanie TTS
                    
                    break; 

                } else {
                    displayMessage("AI neposkytla 쬴adnu odpove캞. (Pr치zdna odpove캞 od modelu)", 'ai');
                }
            } catch (error) {
                console.error("Chyba po캜as volania API:", error);
                
                if (attempt === maxRetries) {
                    const errorMessage = `Nastala kritick치 chyba pri komunik치cii s AI po ${maxRetries} pokusoch. (${error.message})`;
                    displayMessage(errorMessage, 'ai');
                }
            }
        }

        setLoading(false);
    }
    
    // --- Spustenie aplik치cie a event listenery ---

    window.onload = function () {
        init3D();
        animate3D();
        checkAndApplyRateLimit(); 
        
        // Listener pre tla캜idlo CHAT (Odosla콘) - sp칰코콘a sa formul치rom (typ="submit")
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const userQuery = input.value.trim();
            if (!userQuery) return;
            
            if (!apiKey) {
                displayMessage("CHYBA: API k쮂줷 nie je nastaven칳. (Nedostato캜n치 autoriz치cia)", 'ai');
                return;
            }
            sendChatQuery(userQuery);
        });

        // Listener pre tla캜idlo OBR츼ZOK (Generova콘 Obr치zok) - sp칰코콘a sa kliknut칤m (typ="button")
        sendImageButton.addEventListener('click', async () => {
            const userPrompt = input.value.trim();
            
            if (!userPrompt) {
                displayMessage("Pros칤m, zadajte popis obr치zku, ktor칳 chcete vygenerova콘, do textov칠ho po쬬.", 'ai');
                return;
            }

            if (!apiKey) {
                displayMessage("CHYBA: API k쮂줷 nie je nastaven칳. (Nedostato캜n치 autoriz치cia)", 'ai');
                return;
            }

            // Zobrazenie promptu ako spr치vy
            displayMessage(`Po쬴adavka na obr치zok: "${userPrompt}"`, 'user');
            input.value = '';
            
            await generateImageFromPrompt(userPrompt);
        });


        // Pre캜칤tanie 칰vodnej spr치vy po na캜칤tan칤 hlasov
        const initialMessageText = "Vitaj! Model bol teraz aktualizovan칳. Ak chcete vytvori콘 obr치zok vo form치te 16:9 s textom, zadajte popis do po쬬 a kliknite na tla캜idlo Generova콘 Obr치zok.";
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = () => {
                populateVoiceList();
                // Speak the initial message only if it hasn't been spoken yet
                if (messagesDiv.children.length === 1) { 
                     speakText(initialMessageText);
                }
            };
        } else {
            // Fallback pre r칳chlej코ie prehliada캜e
            setTimeout(() => {
                if (messagesDiv.children.length === 1) { 
                     speakText(initialMessageText);
                }
            }, 500);
        }
    }

</script>
</body>
</html>












